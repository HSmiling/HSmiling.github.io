<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>日常学习笔记</title>
      <link href="/2022/03/06/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/03/06/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>开始恢复日常更新啦<del>新学期要继续努力学习呀，争取每周更哟</del></p><h1 id="Python日常笔记"><a href="#Python日常笔记" class="headerlink" title="Python日常笔记"></a>Python日常笔记</h1><h2 id="PYPI中项目包部署安装"><a href="#PYPI中项目包部署安装" class="headerlink" title="PYPI中项目包部署安装"></a>PYPI中项目包部署安装</h2><blockquote><p>参考博客：<a href="https://blog.csdn.net/jss19940414/article/details/85079727">(20条消息) 如何安装pypi.org下载下来的模块_jss19940414的博客-CSDN博客</a></p></blockquote><p>先将相应模块的压缩包从官网中下载到本地并进行解压，从cmd中进入项目目录，键入</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python setup.py build    #编译</span><br><span class="line">python setup.py install  #安装</span><br></pre></td></tr></table></figure><p>注：在安装相应包时需要注意要求的python及其他模块的版本</p><h2 id="包的相对导入问题"><a href="#包的相对导入问题" class="headerlink" title="包的相对导入问题"></a>包的相对导入问题</h2><p>间接包引入报错：ImportError: attempted relative import with no known parent package</p><p><img src="C:\Users\Rita0914\AppData\Roaming\Typora\typora-user-images\image-20220105153631123.png" alt="image-20220105153631123"></p><p><strong>原因</strong></p><p>相对导入应当使用于包（由多个或多层<code>*.py</code>模块组成）内部，用于内部模块功能之间的相互调用，而包文件内部任意模块及功能则应当通过外部脚本使用import调用，不能单独执行！</p><p>发生以上错误的原因是：当前执行的解释器运行于包内部，因此无法获取任何与包含该模块的包的任何信息。</p><p><strong>解决方案</strong></p><p>将相对引入改为绝对引入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from curvefitting.ui.MainWindow import Ui_MainWindow</span><br></pre></td></tr></table></figure><blockquote><p>参考博客:<a href="https://blog.csdn.net/weixin_43958105/article/details/114012590">(20条消息) 【一分钟解决】Python报错ImportError: attempted relative import with no known parent package_Jared Yam的博客-CSDN博客</a></p></blockquote><h2 id="Dataclass使用"><a href="#Dataclass使用" class="headerlink" title="Dataclass使用"></a>Dataclass使用</h2><p>python3.7提供装饰器dataclass，用于将类转换为dataclass。</p><p><strong>定义</strong></p><p>广义上看是一个类，其属性均可公开访问，带有默认值且均可修改，类中含有属性相关类方法；是一个含有数据及操作数据方法的容器</p><blockquote><p>可参考基本使用：<a href="https://www.jb51.net/article/156793.htm">Python3.7 dataclass使用指南小结_python_脚本之家 (jb51.net)</a></p></blockquote><h1 id="github报错"><a href="#github报错" class="headerlink" title="github报错"></a>github报错</h1><p>git出现OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054错误</p><p><strong>解决方案</strong></p><p>git键入以下命令行：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>uni-app框架(二)：基础知识</title>
      <link href="/2022/01/21/uni-app%E6%A1%86%E6%9E%B6(%E4%BA%8C)%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/01/21/uni-app%E6%A1%86%E6%9E%B6(%E4%BA%8C)%EF%BC%9A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="Uni-app基础框架"><a href="#Uni-app基础框架" class="headerlink" title="Uni-app基础框架"></a>Uni-app基础框架</h1><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a><strong>模板语法</strong></h2><p>v-bind：可以简写成：，组件属性使用data中定义的数据变量，或者组件属性使用表达式需使用v-bind绑定</p><p>v-on(@)：可以简写成@，绑定事件</p><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a><strong>数据绑定</strong></h2><p>data：用于初始化数据</p><p>v-model：数据双向绑定</p><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a><strong>条件判断</strong></h2><p>v-if：条件判断，决定某个内容或者区块是否挂载（v-else）</p><p>v-show：条件判断，决定某个内容或者区块是否显示</p><p>三元运算符可用于简单逻辑判断</p><p>空标签（template、block）：可用于判断</p><h2 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a><strong>列表渲染</strong></h2><p>v-for：可以遍历数组和对象</p><h2 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a><strong>事件绑定</strong></h2><p>使用v-on绑定事件（也可以简写成@）</p><p>使用.stop可以阻止事件穿透</p><h2 id="基础组件"><a href="#基础组件" class="headerlink" title="基础组件"></a><strong>基础组件</strong></h2><p>可以看官网中的内容：<a href="https://uniapp.dcloud.io/component/README">组件概述 - uni-app官网 (dcloud.io)</a></p><h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a><strong>自定义组件</strong></h2><p>components文件夹中新建组件</p><p>easycom规范：<a href="https://uniapp.dcloud.io/component/README?id=easycom%E7%BB%84%E4%BB%B6%E8%A7%84%E8%8C%83">组件概述 - uni-app官网 (dcloud.io)</a></p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><strong>生命周期</strong></h2><h3 id="应用生命周期"><a href="#应用生命周期" class="headerlink" title="应用生命周期"></a>应用生命周期</h3><ul><li><p>onLaunch：应用初始化完成执行，全程只执行一次（登录、全局变量）</p></li><li><p>onShow：应用显示的时候执行，或者从后台进入前台</p></li><li><p>onHide：应用隐藏时执行，或从前台进入后台</p></li></ul><h3 id="页面生命周期"><a href="#页面生命周期" class="headerlink" title="页面生命周期"></a>页面生命周期</h3><ul><li><p>onLoad：页面加载时触发</p></li><li><p>onReady：页面初次渲染时触发</p></li><li><p>onShow：页面显示时触发</p></li><li><p>onHide：页面隐藏时触发</p></li><li><p>onUnload：页面卸载时触发</p></li></ul><h3 id="组件生命周期"><a href="#组件生命周期" class="headerlink" title="组件生命周期"></a>组件生命周期</h3><ul><li><p>beforecreate：在实例初始化后，数据观测和event/watcher事件之前配置</p></li><li><p>created</p><p>在实例创建完成后被立即调用。在这一步中，实例已完成如下配置：数据观测，property和方法的运算、watch/event事件回调。然而，挂载阶段尚未开始，set property目前不可用</p></li><li><p>mounted</p><p>实例被挂载后调用，这时Vue.createApp({}).mount()被新创建的vm.Sel替换。若根实例挂载到一个文档的元素上，当mounted被调用时vm.Sel也在文档内</p></li><li><p>unmounted</p><p>卸载组件实例后调用，调用此钩子时，组件实例的所用指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载</p></li></ul><h1 id="github上传问题"><a href="#github上传问题" class="headerlink" title="github上传问题"></a>github上传问题</h1><p><a href="https://www.cnblogs.com/steamed-twisted-roll/p/14155092.html">Logon failed, use ctrl+c to cancel basic credential prompt. - 潇湘羽西 - 博客园 (cnblogs.com)</a></p><p>遇到密码认证错误，参考上面博客，运用添加token解决问题</p><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/202201211101647.png" alt="新建git仓库后的基础指令"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>学习视频：<a href="https://www.bilibili.com/video/BV13U4y1E7z8?p=20">【uni-app】2021最新版uni-app电商项目实战【已完结】_哔哩哔哩_bilibili</a></p><p>uni-app官网：<a href="https://uniapp.dcloud.io/">uni-app官网 (dcloud.io)</a></p><p>uView官网：<a href="https://v1.uviewui.com/">uView - 多平台快速开发的UI框架 - uni-app UI框架 (uviewui.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker和k8s(一)基础概念</title>
      <link href="/2022/01/07/docker%E5%92%8Ck8s(%E4%B8%80)%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/01/07/docker%E5%92%8Ck8s(%E4%B8%80)%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h1><h2 id="docker基本概念"><a href="#docker基本概念" class="headerlink" title="docker基本概念"></a>docker基本概念</h2><p><strong>镜像 Image</strong></p><p>一个特殊的文件系统，除提供容器运行时所需程序、库、资源、配置等文件外，还包括为运行时准备的一些配置参数，镜像中不包含任何动态数据，其内容构建后不会改变。</p><p>类似于常见虚拟机时使用的镜像，但这个镜像便于移动</p><p><strong>容器 Container</strong></p><p>由docker镜像创建的运行实例，实质是进程，运行于属于自己独立的命名空间。镜像是静态的定义，容器是镜像运行时的实体。每个容器间是相互隔离的，容器中会运行特定的应用，包含特定应用的代码及所需的依赖文件。</p><p>类似于虚拟机中创建好的虚拟机系统</p><p><strong>仓库 Repository</strong></p><p>集中存储、分发镜像的服务，类似于Github理解</p><h2 id="docker基础命令"><a href="#docker基础命令" class="headerlink" title="docker基础命令"></a>docker基础命令</h2><p><strong>docker启动和关闭</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动docker</span></span><br><span class="line">sudo service docker start</span><br><span class="line"><span class="comment"># 重启docker</span></span><br><span class="line">sudo service docker restart</span><br><span class="line"><span class="comment"># 停止docker</span></span><br><span class="line">sudo service docker stop</span><br></pre></td></tr></table></figure><h3 id="镜像常用指令"><a href="#镜像常用指令" class="headerlink" title="镜像常用指令"></a>镜像常用指令</h3><p><strong>获取当前所有镜像</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><p><strong>拉取镜像</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 官方镜像</span></span><br><span class="line">docker image pull 镜像名称 </span><br><span class="line"><span class="comment"># 或简写为 </span></span><br><span class="line">docker pull 镜像名称</span><br><span class="line"><span class="comment"># 比如</span></span><br><span class="line">docker pull ubuntu</span><br><span class="line">docker pull ubuntu:16.04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 个人镜像</span></span><br><span class="line">docker pull 仓库名称/镜像名称</span><br><span class="line">docker pull xunmi/django</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三方仓库拉去</span></span><br><span class="line">docker pull 第三方仓库地址/仓库名称/镜像名称</span><br><span class="line">docker pull hub.c.163.com/library/mysql:latest</span><br><span class="line">(默认仓库名为library,所有从官方获取镜像相当于`sudo docker image pull library/镜像名称`)</span><br></pre></td></tr></table></figure><p><strong>删除镜像</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># docker image rm 镜像名或镜像ID 或 docker rmi 镜像名或镜像ID</span></span><br><span class="line">docker image rm hello-world</span><br><span class="line">docker rmi 9e64176cd8a2</span><br></pre></td></tr></table></figure><p>若由容器使用该镜像，需先删除容器，否则可能会报错</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm 容器ID</span><br></pre></td></tr></table></figure><p>删除指令区别如下：</p><ul><li>docker rm：删除一个或多个容器</li><li>docker rmi：删除一个或多个镜像</li><li>docker prune：用于删除不再使用的docker对象</li></ul><p><strong>加载镜像</strong></p><p>旨在将只读类型的镜像加载成可运行环境，即变成容器：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] 镜像名 [向启动容器中传入的命令]</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">常用可选参数</th><th>作用</th></tr></thead><tbody><tr><td align="center">-i</td><td>表示以交互模式运行容器</td></tr><tr><td align="center">-d</td><td>会创建一个守护式容器在后台运行(这样创建容器后不会自动登录容器)。</td></tr><tr><td align="center">-t</td><td>表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</td></tr><tr><td align="center">–name</td><td>为创建的容器命名。(默认会随机给名字,不支持中文字符!!!)</td></tr><tr><td align="center">-v</td><td>表示目录映射关系，即宿主机目录:容器中目录。注意:最好做目录映射，在宿主机上做修改，然后共享到容器上。</td></tr><tr><td align="center">-p</td><td>表示端口映射，即宿主机端口:容器中端口。 比如:<code>-p 8080:80</code> 就是将容器中的80端口,映射到主机中的8080端口</td></tr><tr><td align="center">–network=host</td><td>表示将主机的网络环境映射到容器中，使容器的网络与主机相同。每个 Docker 容器都有自己的网络连接空间连接到虚拟 LAN。使用此命令则会让容器和主机共享一个网络空间。</td></tr></tbody></table><h3 id="容器常用指令"><a href="#容器常用指令" class="headerlink" title="容器常用指令"></a>容器常用指令</h3><p><strong>查看容器</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前所有正在运行的容器</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="comment"># 查看当前所有的容器</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="comment"># 使用过滤器(除了name外,常用的还可以指定id:id= 、所有停止的容器:status=exited,正在运行的容器:status=running 等)</span></span><br><span class="line">docker ps -f name=指定的名字</span><br><span class="line"><span class="comment"># 显示2个上次创建的容器(2可以改变)</span></span><br><span class="line">docker ps -n 2</span><br><span class="line"><span class="comment"># 显示最新创建的容器（包括所有状态）</span></span><br><span class="line">docker ps -l</span><br><span class="line"><span class="comment"># 仅显示ip</span></span><br><span class="line">docker ps -q</span><br><span class="line"> <span class="comment"># 显示容器大小</span></span><br><span class="line">docker ps -s</span><br></pre></td></tr></table></figure><p><strong>容器的启动和关闭</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止容器</span></span><br><span class="line">docker container stop 容器名或容器id</span><br><span class="line"><span class="comment"># 或可简写为</span></span><br><span class="line">docker stop 容器名或容器id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制关闭容器</span></span><br><span class="line">docker container <span class="built_in">kill</span> 容器名或容器id</span><br><span class="line"><span class="comment"># 或可简写为</span></span><br><span class="line">docker <span class="built_in">kill</span> 容器名或容器id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动容器</span></span><br><span class="line">docker container start 容器名或容器id</span><br><span class="line"><span class="comment"># 或可简写为</span></span><br><span class="line">docker start 容器名或容器id</span><br></pre></td></tr></table></figure><p><strong>删除容器</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用rm删除容器</span></span><br><span class="line">docker rm 容器名或容器id</span><br><span class="line"><span class="comment"># 列如</span></span><br><span class="line">docker rm docker-test</span><br></pre></td></tr></table></figure><p><strong>容器制作成镜像</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将容器制作成镜像</span></span><br><span class="line">docker commit 容器名 镜像名</span><br><span class="line"><span class="comment"># 镜像打包备份(打包备份的文件会自动存放在当前命令行的路径下,如果想让保存的文件可以打开,可以加.tar后缀)</span></span><br><span class="line">docker save -o 保存的文件名 镜像名</span><br><span class="line"><span class="comment"># 镜像解压</span></span><br><span class="line">docker load -i 文件路径/备份文件</span><br></pre></td></tr></table></figure><p>参考博客：</p><p><a href="https://blog.csdn.net/qq_39611230/article/details/108641842?ops_request_misc=%7B%22request_id%22:%22163832738416780265495321%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163832738416780265495321&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-108641842.pc_search_result_control_group&utm_term=docker+desktop%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8&spm=1018.2226.3001.4187">(10条消息) 从零开始的Docker Desktop使用,Docker快速上手 （￣︶￣）↗ Docker介绍和基础使用_寻觅的博客-CSDN博客</a></p><h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><p><a href="https://blog.kaixindeken.top/archives/16">https://blog.kaixindeken.top/archives/16</a></p><h2 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h2><p><strong>定义</strong></p><p>kubernetes是一个开源、用于管理云平台中多个主机上的容器化的应用，提供应用部署、规划、更新、维护的一种机制，旨在使部署容器化的应用简单且高效。</p><p><strong>核心特点</strong></p><p>自主管理容器以保证云平台中容器按用户期望状态运行</p><p><strong>作用</strong></p><ul><li>自动化容器的部署和复制</li><li>随时扩展或收缩容器规模</li><li>将容器组织成组，并且提供容器间的负载均衡</li><li>很容易地升级应用程序容器的新版本</li><li>提供容器弹性</li></ul><h2 id="设计架构"><a href="#设计架构" class="headerlink" title="设计架构"></a>设计架构</h2><p>参考链接：<a href="https://www.kubernetes.org.cn/kubernetes%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84">Kubernetes（k8s）中文文档 Kubernetes设计架构_Kubernetes中文社区</a></p><p>kubernetes集群基于分布式存储系统，包括节点代理kubelet和Master组件，架构图：</p><img src="https://img-blog.csdnimg.cn/20190410181400547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNDMwMzIy,size_16,color_FFFFFF,t_70" alt="设计架构图" style="zoom:67%;" /><p>其中服务分为运行在工作节点上的服务和组成集群级别控制板的服务。kubernetes节点中受Master控制的有运行应用容器必备服务，每个节点上运行Docker，Docker负责所有具体的映像下载和容器运行。</p><p>​                 <img src="https://feisky.gitbooks.io/kubernetes/architecture/images/14791969222306.png" alt="img" style="zoom: 25%;" /><img src="https://feisky.gitbooks.io/kubernetes/architecture/images/14791969311297.png" alt="img" style="zoom: 25%;" /></p><p><strong>kubernetes核心组件</strong></p><table><thead><tr><th align="center">组件</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">etcd</td><td align="center">保存整个集群状态（所有master的持续状态都存在etcd的一个实例中）</td></tr><tr><td align="center">API Server</td><td align="center">提供资源操作唯一入口，提供认证、授权、访问控制、API注册和发现等机制</td></tr><tr><td align="center">Controller Manager</td><td align="center">负责维护集群状态</td></tr><tr><td align="center">Scheduler</td><td align="center">复杂资源调度，按照预定的调度策略将Pod调度到相应的机器上</td></tr><tr><td align="center">Kubelet</td><td align="center">负责维护容器生命周期，负责Volume和网络的管理（负责管理pods和它们上面的容器，images镜像、volumes、etc）</td></tr><tr><td align="center">Container Runtime</td><td align="center">负责镜像管理以及Pod和容器的真正运行</td></tr><tr><td align="center">Kube-proxy</td><td align="center">负责为Service提供cluster内部的服务发现和负载均衡</td></tr></tbody></table><p><strong>推荐的Add-ons（附加组件）</strong></p><table><thead><tr><th align="center">组件</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">kube-dns</td><td align="center">负责为整个集群提供DNS服务</td></tr><tr><td align="center">Ingress Controller</td><td align="center">为服务提供外网入口</td></tr><tr><td align="center">Heapster</td><td align="center">提供资源监控</td></tr><tr><td align="center">Dashboard</td><td align="center">提供GUI</td></tr><tr><td align="center">Federation</td><td align="center">提供跨可用区的集群</td></tr><tr><td align="center">Fluentd-elasticsearch</td><td align="center">提供集群日志采集、存储与查询</td></tr></tbody></table><p><strong>分层架构</strong></p><img src="https://feisky.gitbooks.io/kubernetes/architecture/images/14937095836427.jpg" alt="img" style="zoom:50%;" /><table><thead><tr><th align="center">层</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">核心层</td><td align="center">最核心功能，对外提供API构建高层的应用，对内提供插件式应用执行环境</td></tr><tr><td align="center">应用层</td><td align="center">部署和路由</td></tr><tr><td align="center">管理层</td><td align="center">系统度量、自动化、策略管理</td></tr><tr><td align="center">接口层</td><td align="center">kubectl命令行工具、客户端SDK、集群联邦</td></tr><tr><td align="center">生态系统</td><td align="center">在接口层之上的庞大容器集群管理调度的生态系统</td></tr></tbody></table><h2 id="核心技术概念"><a href="#核心技术概念" class="headerlink" title="核心技术概念"></a>核心技术概念</h2><p>参考：<a href="https://www.kancloud.cn/docker_practice/docker_practice/469874">基本概念 · Docker —— 从入门到实践 · 看云 (kancloud.cn)</a><img src="https://box.kancloud.cn/2015-12-16_5671229a8fbe0.jpg" alt="img"></p><table><thead><tr><th align="center">概念</th><th>含义</th></tr></thead><tbody><tr><td align="center">节点(Node)</td><td>一个节点是一个运行 Kubernetes 中的主机</td></tr><tr><td align="center">容器组(Pod)</td><td>一个 Pod 对应于由若干容器组成的一个容器组，同个组内的容器共享一个存储卷</td></tr><tr><td align="center">容器组生命周期(pos-states)</td><td>包含所有容器状态集合，包括容器组状态类型，容器组生命周期，事件，重启策略，以及 replication controllers</td></tr><tr><td align="center">Replication Controllers</td><td>主要负责指定数量的 pod 在同一时间一起运行</td></tr><tr><td align="center">服务(Services)</td><td>一个 Kubernetes 服务是容器组逻辑的高级抽象，同时也对外提供访问容器组的策略</td></tr><tr><td align="center">卷(volumes)</td><td>一个卷就是一个目录，容器对其有访问权限</td></tr><tr><td align="center">标签(labels)</td><td>标签是用来连接一组对象的，比如容器组。标签可以被用来组织和选择子对象</td></tr><tr><td align="center">接口权限(accessing_the_api)</td><td>端口，IP 地址和代理的防火墙规则</td></tr><tr><td align="center">web界面(ux)</td><td>用户可以通过 web 界面操作 Kubernetes</td></tr><tr><td align="center">命令行操作(cli)</td><td><code>kubectl</code>命令</td></tr></tbody></table><p><strong>Pod</strong></p><p>Pod是在K8s集群中运行部署应用或服务的最小单元，它是可以支持多容器的。Pod的设计理念是支持多个容器在一个Pod中共享网络地址和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。Pod对多容器的支持是K8s最基础的设计理念。</p>]]></content>
      
      
      <categories>
          
          <category> 无服务器运算 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>uni-app框架(一)：安装、部署和入门</title>
      <link href="/2021/12/29/uni-app%E6%A1%86%E6%9E%B6(%E4%B8%80)%EF%BC%9A%E5%AE%89%E8%A3%85%E3%80%81%E9%83%A8%E7%BD%B2%E5%92%8C%E5%85%A5%E9%97%A8/"/>
      <url>/2021/12/29/uni-app%E6%A1%86%E6%9E%B6(%E4%B8%80)%EF%BC%9A%E5%AE%89%E8%A3%85%E3%80%81%E9%83%A8%E7%BD%B2%E5%92%8C%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>拟采用uni-app框架开发一款微信小程序，期望记录该过程中遇到的问题，遂开启该系列笔记</p><h1 id="uni-app安装部署"><a href="#uni-app安装部署" class="headerlink" title="uni-app安装部署"></a>uni-app安装部署</h1><p>uni-app官网地址：<a href="https://uniapp.dcloud.io/">uni-app官网 (dcloud.io)</a></p><p><strong>简介</strong></p><p>uni-app作为使用vue.js开发所有前端应用的框架，能够以一套代码发布到多个平台，通过参考，由于uni-app采用vue框架，且较于其他框架而言更加活跃，资料搜寻成本相对较低，故拟选择uni-app框架作为开发框架。</p><blockquote><p>参考博客：<br><a href="https://www.jianshu.com/p/46cc41abe91a">微信小程序主流框架汇总 - 简书 (jianshu.com)</a></p><p><a href="https://www.zhihu.com/question/280282750/answer/1284136587">(22 封私信 / 80 条消息) 微信小程序UI框架有哪些? - 知乎 (zhihu.com)</a></p><p><a href="https://developers.weixin.qq.com/community/develop/article/doc/000eaadb944de06374485c3ed51813">小程序多端框架全面测评 | 微信开放社区 (qq.com)</a></p></blockquote><p><strong>工具安装 (微信开发者工具+HBuilderX)</strong></p><p>uni-app可使用以下两种方式快速创建项目：</p><ul><li>可视化界面（较简单，无需配置node.js）</li><li>vue-cli命令行</li></ul><p>我选择可视化界面，需下载HBuilderX通用前端开发工具：</p><blockquote><p>HBuilderX官方下载地址：<a href="https://www.dcloud.io/hbuilderx.html">HBuilderX-高效极客技巧 (dcloud.io)</a></p></blockquote><p>注：下载APP开发板可直接使用，标准版需要再安装uni-app插件</p><p>部署微信小程序还需要提前下载微信开发者工具</p><p><strong>创建uni-app</strong></p><p>按照官网的教程进行安装创建，微信小程序部署部分如网页中第4部分所示：</p><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/202201051130193.png" alt="image-20211229105940572"></p><blockquote><p>官网参考：<a href="https://uniapp.dcloud.io/quickstart-hx">1. 通过 HBuilderX 可视化界面 - uni-app官网 (dcloud.io)</a></p></blockquote><p>注：运行前需提前打开并登录微信开发者工具，同时需要在【微信开发者工具】里打开http或cli访问的开关，即在设置-&gt;安全设置中开启，否则报错如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uni-app Error: read EBADF at Pipe.onStreamRead(internal/stream_base_commons.js:183:27)</span><br></pre></td></tr></table></figure><blockquote><p>问题解决参考链接：<a href="https://blog.csdn.net/qq_19734597/article/details/116653759">(19条消息) uni-app Error: read EBADF at Pipe.onStreamRead (internal/stream_base_commons.js:183:27)_陈晓清的博客-CSDN博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
            <tag> uni-app </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PDSDN：一种多租户云数据中心环境策略驱动的SDN控制器改进方案</title>
      <link href="/2021/12/25/PDSDN%EF%BC%9A%E4%B8%80%E7%A7%8D%E5%A4%9A%E7%A7%9F%E6%88%B7%E4%BA%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E7%8E%AF%E5%A2%83%E7%AD%96%E7%95%A5%E9%A9%B1%E5%8A%A8%E7%9A%84SDN%E6%8E%A7%E5%88%B6%E5%99%A8%E6%94%B9%E8%BF%9B%E6%96%B9%E6%A1%88/"/>
      <url>/2021/12/25/PDSDN%EF%BC%9A%E4%B8%80%E7%A7%8D%E5%A4%9A%E7%A7%9F%E6%88%B7%E4%BA%91%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%BF%83%E7%8E%AF%E5%A2%83%E7%AD%96%E7%95%A5%E9%A9%B1%E5%8A%A8%E7%9A%84SDN%E6%8E%A7%E5%88%B6%E5%99%A8%E6%94%B9%E8%BF%9B%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>该文献提出一种云数据中心环境下基于多租户策略驱动的SDN控制器方案，以满足管理和性能需求。其核心是PDSDN系统，该系统通过自定义租户策略批量处理租户的需求。</p><ul><li>2021-12-20：初次阅读论文，接触SDN，梳理架构</li><li>2021-12-21：阅读第一节部分</li><li>2021-12-22：阅读第二节1、2部分，学习租户操作优先级分配算法，对于基础策略的相关专业概念还需要进一步深入了解一下</li><li>2021-12-24：初步阅读第2、3节部分，对测试实验的验证原理以及策略模块的实现具体原理可以继续深入深入</li><li>2021-12-25：将初步内容阅读完毕，但是有关SDN相关技术架构和网络架构等知识，需要进一步学习探究</li></ul><p>整理OpenFlow、SDN、网络的学习笔记，留个坑~</p><p>后期想做一个网络学习的系列，留个坑~</p><h1 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h1><h2 id="论文标题"><a href="#论文标题" class="headerlink" title="论文标题"></a>论文标题</h2><p>《PDSDN: A policy-driven SDN controller improving scheme for multi-tenant cloud datacenter environments》</p><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p>云计算、软件定义网络(SDN)、策略驱动、云数据中心、虚拟网络</p><h2 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h2><p>SDN技术可运用于管理云平台的网络，收到企业的广泛关注。云计算数据中心使用SDN控制器定义自身虚拟网络、虚拟防火墙。租户通过云平台的网络组件调用SDN控制器北向接口管理云平台的网络。而当租户数量较大时，SDN与云平台交互频繁，容易出现冗余等问题。为简化SDN与云平台交互过程，该文献提出一种基于策略驱动的批处理网络操作SDN控制器方案，其中云数据中心管理器将与SDN相关的策略发送到SDN控制器，SDN控制器根据用户的权限和操作优先级对接收到的策略进行处理。网络资源管理可以与云数据中心环境中的其他资源管理有效集成。</p><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>该文献提出一种云数据中心环境下基于多租户策略驱动的SDN控制器方案，以满足管理和性能需求。其核心是PDSDN系统，该系统通过自定义租户策略批量处理租户的需求。主要贡献如下：</p><ul><li><p>减少平台负担。SDN控制器能够与云数据中心平台工作有效集成，并为其分担部分工作</p></li><li><p>便于使用。租户能够以直观方式定义虚拟网络、虚拟防火墙及流规则，无需编写程序或使用软件调用由SDN控制器提供的接口</p></li><li><p>PDSDN策略与租户访问策略、对象存储策略等云平台策略有效结合。租户、管理员共同管理云平台和SDN控制器</p></li><li><p>计算资源、租户请求时间的节省。云平台通过解析租户定义的策略，具有更好的管理网络资源的性能</p></li></ul><h1 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><ul><li><p>SDN基本思想</p><p>将网络设备控制功能从网络设备数据转发功能中分离。将交换器、路由器等控制功能转移到中央SDN控制器中，实现控制平面与数据平面的完全分离。</p></li><li><p>SDN控制器集成云平台模型</p><ul><li><p>云平台网络组件作为访问SDN控制器的应用程序</p><p>应用程序通过网络组件操作SDN控制器并管理其网络资源，但应用程序操作受到该模式下网络组件限制，应直接调用SDN北向接口</p></li><li><p>云平台网络组件和SDN控制器构成点对点关系</p><p>租户应用程序通过SDN控制器直接管理租户网络资源</p></li><li><p>云平台网络组件为SDN控制器提供南向接口</p><p>应用程序通过使用SDN控制器的网络组件管理底层网络资源</p></li></ul></li></ul><p>目前的模型致力于网络组件，未能达到资源管理的完全交付；在真实情况中若能将租户的请求批量发送至SDN控制器，并交由其统一处理，可以减少租户工作量，提高SDN控制器的执行效率。</p><p>该文献提出一种云数据中心环境下基于多租户策略驱动的SDN控制器方案，以满足管理和性能需求。其核心是PDSDN系统，该系统通过自定义租户策略批量处理租户的需求。</p><h2 id="PDSDN设计方案"><a href="#PDSDN设计方案" class="headerlink" title="PDSDN设计方案"></a>PDSDN设计方案</h2><p><strong>基础策略定义</strong></p><p>策略定义基本目标与AWS策略定义完全兼容，以实现统一策略分析。PDSDN使用SDN集成语言SIStatement，其中SIStatement使用SIPrincipal、SIAction、SIResource扩展AWS函数</p><ul><li><p>SIPrincipal</p><p>扩展AWS语句主元素，基本形式如下：<br>$$<br>SIPricipal: {SDN:TenantUserID}<br>$$<br>keyword SDN表示该元素是一个与SDN相关的操作。</p></li><li><p>SIAction</p><p>AWS动作元素，代表与网络管理相关操作,，可依据其定义进行任意扩展。如：创建虚拟子网定义为：<br>$$<br>SIAction: CreateVirtualNetwork<br>$$</p></li><li><p>SIResource</p><p>从AWS语句资源元素扩展，SIResource的值与SIAction的值相关，并依照其值进行修改。SIResource包含同一租户多个虚拟子网定义，使得租户可在一个策略文件中创建多个虚拟子网，方便租户管理网络资源</p></li></ul><p>（该部分最后一段没咋看懂，留个坑）</p><p><strong>权限管理</strong></p><p>其关键在于如何限制租户自定义策略的权限，以确保云数据中心管理员对租户拥有最终权限。</p><ul><li><p>策略优先级值</p><p>参照OpenFlow协议，采用对策略划分优先级值的方法：</p><p>所有优先级值范围0-255，管理员策略优先级值范围为128-255，租户策略优先级值范围为0-127。</p></li><li><p>管理员策略</p><p>强调原子操作的定义和默认策略的描述</p></li><li><p>租户策略</p><p>划分为基本优先级值和优先级偏移值，基本优先级值时基于应用程序场景的固定值</p></li></ul><p>策略分解为解析租户策略文件后执行的原子动作，则有：<br>$$<br>租户动作的实际优先级值=动作固定优先级值+优先级偏移值（租户策略优先级值等于其操作的优先级值）<br>$$<br>其中，优先级偏移值是管理员动作的固定优先级值与基本优先级值之间的差值</p><p>为防止租户行动实际优先值大于管理员的基本优先值，需要将租户行动固定的优先级值和管理员策略的优先级值限制在更小的范围内。</p><ul><li><p>==租户操作优先级分配算法==</p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211222144504828.png" style="zoom:50%;" /><p>其中A代表一个原子操作，P[A]代表优先级值，a表示固定优先级类型，a的优先级值为p[a]。</p><p>该算法首先计算原子动作的优先级偏移值，在解析租户策略文件时得到固定优先级值，然后得到原子动作的实际优先级值。其中租户原子操作的优先级值的范围为[0,127]，会低于所有管理员的原子操作优先级值</p></li></ul><p><strong>策略冲突处理</strong></p><p>管理员定义具有最高优先级值得默认策略，以解决租户之间所有可能的冲突。</p><ul><li><p>策略冲突解决算法</p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211224150455433.png" style="zoom:50%;" /><p>首先确定冲突是否由管理员使用预定义策略解决，若无法解决，则由管理员全局默认策略解决。</p></li></ul><h2 id="PDSDN实现"><a href="#PDSDN实现" class="headerlink" title="PDSDN实现"></a>PDSDN实现</h2><p><strong>PDSDN体系结构</strong></p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211224160016028.png" alt="image-20211224160016028" style="zoom:50%;" /><p>策略模块中包含策略文件读取模块、策略文件解析模块和策略执行模块。PDSDN系统调用本地API在物理网络上执行相应操作。</p><blockquote><p>PDSDN系统维护一个策略文件系统，策略文件系统直接从云数据中心平台读取策略文件，它还接受租户将策略直接写入策略文件系统。在策略模块中，策略文件系统会维护所有的策略文件，而策略文件监控模块则会监控策略文件的变化。如果策略文件没有改变，则策略文件监控模块将继续定期监控这些文件。如果策略文件已被更改，则策略文件监控模块将通知策略文件解析模块和策略执行模块。策略执行模块根据操作类型执行相应的操作，然后返回到监控过程中。</p></blockquote><p><strong>策略模块</strong></p><p>其工作流程如下（具体流程认真看图）：</p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211224160553370.png" alt="image-20211224160553370" style="zoom:50%;" /><ul><li><p>策略文件监控模块</p><p>定期监视策略文件的更改</p></li><li><p>策略文件解析模块</p><p>通过解析文件提取SDN相关操作，发送到云数据中心平台执行，实现对SDN控制器和云数据中心平台策略的同一管理和分析</p></li><li><p>线程池</p><p>每个操作会创建一个新线程，并在线程池中执行；线程池中有统一管理线程执行器定义一个统一的操作接口来调用。各操作执行器通过调用接口具有较高的可扩展性，统一执行器通过调用接口实现对操作执行器的统一管理。</p></li></ul><p>最后，操作执行器通过调用SDN控制器的本地api来完成其任务，并实现整个PDSDN系统的功能。这样，PDSDN系统就实现了通过SDN控制器来管理整个网络的目标。</p><h2 id="实验评估"><a href="#实验评估" class="headerlink" title="实验评估"></a>实验评估</h2><p><strong>功能验证</strong></p><p>通过典型应用程序场景验证PDSDN系统有效性</p><ul><li><p>实验环境</p><p>Openstack，版本Havana，部署3台服务器。</p><p>硬件配置版本：</p><table><thead><tr><th align="center">版本</th><th align="center">DELL PowerEdgeR720</th></tr></thead><tbody><tr><td align="center">CPU</td><td align="center">Intel-XeonE5-2650</td></tr><tr><td align="center">内存</td><td align="center">32GB</td></tr><tr><td align="center">操作系统</td><td align="center">Ubuntu12.04 LTS64bit</td></tr></tbody></table><p>其中一个服务器用于云控制器和Openstack核心服务，一个服务器用于网络节点和计算节点，一个仅用于计算节点。通过创建虚拟子网、创建虚拟防火墙ACL验证PDSDN系统有效性</p></li><li><p>创建虚拟子网</p><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211224162700650.png" alt="image-20211224162700650" style="zoom: 80%;" /><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211224162740480.png" alt="image-20211224162740480" style="zoom: 80%;" /></p><blockquote><p>在实验开始时，虚拟机可以相互通信。20秒后，租户制作他们的策略文件来创建虚拟子网。租户1将他的虚拟机资源放入他的虚拟子网，租户2还将他的虚拟机资源投入他的虚拟子网。图3显示了vm1和vm3由于属于不同的虚拟子网而无法相互通信。vm1与vm3之间的数据传输速率为0，而vm1与vm2之间的数据传输速率等于vm3与vm4之间的数据传输速率。45秒后，租户删除他们的策略文件，或删除他们的虚拟子网资源，然后虚拟机可以再次相互通信。</p></blockquote></li><li><p>创建虚拟防火墙ACL</p><p>在ACL中定义禁止端口之间通信的策略：</p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211224162921878.png" alt="image-20211224162921878" style="zoom: 50%;" /><blockquote><p>实验测量了租户1虚拟子网中vm1和vm2之间的通信。在实验中，我们通过Iperf测量UDP协议的传输带宽，其中两个虚拟机分别通过其端口5001和端口5002建立了两个UDP数据流。在实验开始时，两个数据流共享vm1和vm2之间的带宽。然后租户1启用创建虚拟防火墙的策略，该策略禁止端口5002的通信。基于端口5002的UDP通信带宽降至0，基于端口5001的通信垄断带宽。最后，删除了租户1的策略，两个数据流再次共享带宽。实验验证了端口通信禁止的有效性。</p></blockquote></li></ul><p><strong>性能验证</strong></p><table><thead><tr><th align="center">测试场景</th><th align="center">创建虚拟子网</th></tr></thead><tbody><tr><td align="center">测试对象</td><td align="center">调用本地API、使用PDSDN系统、调用RESTapi</td></tr><tr><td align="center">变量</td><td align="center">租户总数、每个租户的虚拟子网号、每个子网中的虚拟机数量</td></tr><tr><td align="center">需测量参数</td><td align="center">系统处理时间、系统负载增量</td></tr></tbody></table><p>通过创建虚拟子网操作测试性能，在PDSDN运行过程中，一些变量的变化导致PDSDN系统性能和负载的变化，针对上述三个变量采用控制变量法探究其性能，性能衡量指标如下：</p><p>系统处理时间：操作开始到操作结束的时间。PDSDN系统的处理时间是指PDSDN接收和处理由HTTP请求发送的策略文件的时间。</p><p>系统负载增量：通过测量CPU处理时间增长率表示，计算CPU处理时间增长率公式如下：<br>$$<br>CPUinrate = (CPUend - CPUbegin) / CPUbegin<br>$$</p><ul><li><p>增加虚拟子网上主机数量</p><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211225103918450.png" alt="image-20211225103918450" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211225103948100.png" alt="image-20211225103948100" style="zoom: 67%;" /></p><p>测量系统负载增量：当主机数量增加时，PDSDN时间延迟略高于调用本地API，且小于调用RESTapi的处理时间。图6表示PDSDN系统的负载增量仅为40%-60%左右，调用RESTapi的负载增量约为120%-180%左右。结果说明，PDSDN的处理性能优于调用RESTapi。</p></li><li><p>增加租户的虚拟子网数量</p><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211225104412595.png" alt="image-20211225104412595" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211225104435468.png" alt="image-20211225104435468" style="zoom: 33%;" /></p><p>增加虚拟子网主机个数时，调用本地API的处理时间接近常量，但当每个租户虚拟子网数量增加时，本地API调用处理时间随其线性增长。</p><p>虚拟子网数量时限制系统处理时间的瓶颈。虚拟子网增加时，PDSDN的系统负载增量小于调用RESTapi的负载增量。</p></li><li><p>增加租户数量</p><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211225104608572.png" style="zoom:50%;" /><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211225104633940.png" style="zoom:50%;" /></p><p>租户数量时限制系统处理时间的瓶颈。</p><p>如果租户数量增加，策略文件就会增加，这将导致PDSDN系统的策略模块需要处理的策略文件数量增加。所以在初期阶段PDSDN较调用RESTapi的优势并不明显，但当租户数量达到70后，PDSDN的优势较为明显。</p></li></ul><p>PDSDN系统能够减少系统的处理时间。</p><h2 id="相关工作及结论"><a href="#相关工作及结论" class="headerlink" title="相关工作及结论"></a>相关工作及结论</h2><p><strong>结论</strong></p><p>该文献中的工作集中于租户在云环境中的网络策略配置和管理员策略的权限管理，并提出并实现一种基于多租户策略驱动的SDN控制器方案：PDSDN，将租户虚拟子网云与其他虚拟子网隔离。</p><p><strong>未来工作</strong></p><p>同时支持租户在不同场景、不同类型的SDN控制器总定义自身策略。</p><h1 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h1><h2 id="软件定义网络-Software-Defined-Network-SDN"><a href="#软件定义网络-Software-Defined-Network-SDN" class="headerlink" title="软件定义网络(Software Defined Network, SDN)"></a><strong>软件定义网络(Software Defined Network, SDN)</strong></h2><p><strong>定义</strong></p><p>一种新兴的控制与转发分离并直接可编程的网络架构。希望应用软件可以参与对网络的控制管理，满足上层业务需求，通过自动化业务部署简化网络运维。</p><blockquote><p>将复杂的传统网络设备全部对上层应用不可见。上层管理层能够像配置软件程序一样对网络进行简单部署，让网络实现所需要的功能，而不需要一个个配置网络上所有节点的网络设备</p></blockquote><img src="https://pic3.zhimg.com/80/v2-6f6d0d54f2f5fd9748bff99aa2e22a64_720w.jpg?source=1940ef5c" alt="img" style="zoom:50%;" /><p><strong>优势</strong></p><p>控制和转发分离，使得硬件通用化，打破垄断，降低设备成本</p><p>同一管理，集中控制。降低网络维护难度，缩短网络部署周期。</p><p><strong>北向接口与南向接口</strong></p><ul><li><p>北向接口</p><p>提供给其他厂家或运营商进行接入和管理的接口，即向上提供的接口。</p><blockquote><p>其目标是使得业务应用能够便利地调用底层的网络资源和能力。通过北向接口，网络业务的开发者 能以软件编程的形式调用各种网络资源；同时上层的网络资源管理系统可以通过控制器的北向接口全局把控整个网网络的资源状态，并对资源进行统一调度。因为北向接口是直接为业务应用服务的，因此其设计需要密切联系业务应用需求，具有多样化的特征。同时，北向接口的设计是否合理、便捷，以便能被业务应用广泛调 用，会直接影响到SDN控制器厂商的市场前景。</p><p>示例：ORBA（Common Object Request Broker Architecture）、SNMP、Syslog等。Syslog接口主要负责将SNMPAgent产生的告警转换为Syslog协议的格式转发给上级网管系统，功能比较单一。而CORBA和SNMP接口则能提供故障、拓扑、资源等多类接口，完成故障查询，资源查询等多类网管功能。</p></blockquote></li><li><p>南向接口</p><p>管理其他厂家网管或设备的接口，即向下提供的接口。</p><blockquote><p>SDN控制器对网络的控制主要是通过南向接口协议实现,包括链路发现、拓扑管理、策略制定、表项下发等，其中链路发现和拓扑管理主要是控制其利用南向接口的上行通道对底层交换设备上报信息进行统一监控和统计；而策略制定和表项下发则是控制器利用南向接口的下行通道对网络设备进行统一控制。</p><p>示例：SNMP、TR069、SYSLOG、SOAP、SSH等，其中主要的是SNMPv3 和TR069（即CWMP,客户端广域网管理协议）。</p></blockquote></li></ul><p>参考博客：</p><p><a href="https://zhuanlan.zhihu.com/p/74465580">什么是南向接口和北向接口？ - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/hengwu/p/9597428.html">北向接口、南向接口 - qingshan - 博客园 (cnblogs.com)</a></p><h2 id="网络组件"><a href="#网络组件" class="headerlink" title="网络组件"></a>网络组件</h2><p>可以参考这个博客的内容：</p><p><a href="https://pea328.blog.csdn.net/article/details/104468275?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.nonecase">(17条消息) 网络基础（一）什么是网络？ 网络组件基本图标，网络7层，数据传输的过程_H_sen’s Blog-CSDN博客</a></p><h2 id="SIStatement"><a href="#SIStatement" class="headerlink" title="SIStatement"></a>SIStatement</h2><p>该文献中自定义的继承、开发Amazon语句</p><h2 id="OpenFlow协议"><a href="#OpenFlow协议" class="headerlink" title="OpenFlow协议"></a>OpenFlow协议</h2><p>建议流表中的每个流条目均包含一个优先级值，数字越大，优先级值越高</p><p><a href="https://www.cnblogs.com/wn1m/p/11281781.html">OpenFlow和SDN的历史和原理介绍 - 张朝锋 - 博客园 (cnblogs.com)</a></p><h2 id="Floodlight"><a href="#Floodlight" class="headerlink" title="Floodlight"></a>Floodlight</h2><p>SDN控制器</p><p>可参考学习文档(译址)：<a href="http://sherkyoung.github.io/pages/tags.html#floodlight">标签 | Phoenix (sherkyoung.github.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> SDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 ACP 方法的区块链驱动的平行金融科技监管沙箱</title>
      <link href="/2021/12/15/%E5%9F%BA%E4%BA%8E%20ACP%20%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%B9%B3%E8%A1%8C%E9%87%91%E8%9E%8D%E7%A7%91%E6%8A%80%E7%9B%91%E7%AE%A1%E6%B2%99%E7%AE%B1/"/>
      <url>/2021/12/15/%E5%9F%BA%E4%BA%8E%20ACP%20%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%B9%B3%E8%A1%8C%E9%87%91%E8%9E%8D%E7%A7%91%E6%8A%80%E7%9B%91%E7%AE%A1%E6%B2%99%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<p>文献中提出一种基于ACP方法的并行金融科技监管沙箱框架，旨在为金融科技监管沙箱的发展提供有力的引导和参考。该篇文献中并没有提到具体技术细节，主要可用于对领域的了解学习</p><span id="more"></span><ul><li>2021-12-13 初次浏览论文，看完文章的1、2节，将基础信息看了一下，沙箱和监管沙箱的具体含义有待进一步完善，ACP方法需要了解</li><li>2021-12-14 阅读文献第3节，了解沙箱的基本用途和原理，平行智能理论还没太弄明白</li><li>2021-12-15 阅读文献第4节，做好相关笔记，该篇文献处于粗读阶段，其中细节有待反复阅读思考</li></ul><h1 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h1><h2 id="论文标题"><a href="#论文标题" class="headerlink" title="论文标题"></a>论文标题</h2><p>Blockchain-Powered Parallel FinTech Regulatory Sandbox Based on the ACP Approach</p><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p>金融科技(FinTech)、监管沙箱、ACP方法、区块链、智能合约</p><h2 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h2><p>监管沙箱作为新型金融科技监管工具，能有效平衡金融创新与风险。但目前监管沙箱处于手动提交数据的阶段，人工智能和区块链还未被广泛应用。故该篇文献旨在为金融科技监管沙箱的发展提供有力的引导和参考。</p><h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><p>文献中提出一种基于ACP方法的并行金融科技监管沙箱框架，包括人工系统、计算实验、并行执行。同时，为解决数据流质量差、监管迟缓、人工报告等问题提出将区块链技术运用于智能监管沙箱。</p><h1 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h1><p><strong>基本工作原理</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Descriptive Intelligence -&gt; Predictive Intelligence -&gt; Prescriptive Intelligence</span><br></pre></td></tr></table></figure><p>Descriptive Intelligence：人工金融市场被用于描述和构建真实市场的运行状态</p><p>Predictive Intelligence：通过将金融科技产品（或服务）投放至人工金融市场，通过计算实验以测试和评估金融科技的安全性和合规性</p><p>Prescriptive Intelligence：通过人工市场与实际市场对接、比较与分析，实现金融科技监管的管理和优化</p><h2 id="监管沙箱发展与内涵"><a href="#监管沙箱发展与内涵" class="headerlink" title="监管沙箱发展与内涵"></a>监管沙箱发展与内涵</h2><p><strong>监管沙箱定义</strong></p><p>监管沙箱能够为金融科技公司提供一个”安全空间“用以测试公司的创新产品/服务/业务模式。在沙箱期间不会受到立刻受到监管规则的约束。</p><p><strong>监管沙箱优势</strong></p><p>区别于传统监管工具，监管沙箱提供真实但不断收缩的金融市场和一个灵活的监管环境。其中包括适当保障措施，遏制失败后果的同时维护金融体系安全和稳健。</p><p>从使用者的角度而言，可分为以下三种：</p><ul><li><p>监管机构：沙盒可以帮助他们了解前沿技术、运行机制和潜在风险，从而跟上金融科技创新的步伐</p></li><li><p>金融科技企业：沙盒可以减少监管不确定性，增加创新产品/服务的种类和数量，缩短产品进入市场的时间</p></li><li><p>消费者：沙盒可以尽早发现金融创新产品的缺陷，确保有内置的消费者保护措施</p></li></ul><p><strong>虚拟沙箱(Virtual Sandbox)</strong></p><p>虚拟测试环境。金融科技企业邀请消费者进入测试环境，利用公共数据集模拟金融科技产品的运行。由于虚拟性质，不存在损害消费者利益的风险，不损害真实金融市场</p><p><strong>并行监管沙箱(Parallel FinTech Regulatory)</strong></p><p>提供虚拟测试环境，通过并行交互机制和协议将真实金融系统与人工系统连接</p><h2 id="框架的提出"><a href="#框架的提出" class="headerlink" title="框架的提出"></a>框架的提出</h2><p><strong>沙箱步骤</strong></p><ol><li>建模：通过软件定义系统对与实际金融市场相对应的人工金融市场建模</li><li>分析与控制：通过人工系统实时数据对仿真系统更新，从而实现系统的分析与管理</li><li>测试：将新的金融科技产品/服务/商业模式投放至人工市场试运行，进行压力测试、边际测试、加速测试等</li><li>并行：利用平行执行，通过人工系统与实际系统的平行互动、协同演进，实现对实际金融市场有效预测</li></ol><p><strong>实现框架</strong></p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211214110116807.png" style="zoom:50%;" /><p>工作模型如下：</p><ul><li><p>learning and training（学习训练）</p><p>平行监管沙箱能够实例化一个或多个基于特定学习目标的人工金融市场，并在人工市场中快速部署新的金融科技产品。通过人工系统与实际系统连接，使学习者快速掌握金融科技产品在人工系统中的操作以及预测后果，量化学习训练有效性</p></li><li><p>Experiment and evaluation（实验评估）</p><p>调节功能，在模拟真实金融市场环境的人工系统中进行多次测试，寻找能够抵御破坏性攻击的配置解决方案</p></li><li><p>Management and optimaization（管理优化）</p><p>提出的并行监管沙盒也可以作为政府部门和行业组织实施宏观调控和趋势预测的工具</p></li></ul><h2 id="区块链在该框架下的应用"><a href="#区块链在该框架下的应用" class="headerlink" title="区块链在该框架下的应用"></a>区块链在该框架下的应用</h2><p><strong>区块链的监管沙箱中的应用</strong></p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211215105548403.png" style="zoom:50%;" /><p>总体架构如上所示</p><p><strong>沙箱测试数据链上认证</strong></p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211215102419006.png" alt="image-20211215102419006" style="zoom:50%;" /><ul><li><p>认证阶段</p><p>测试项目前：项目宣传信息、客户信息、沙箱测试方案等</p><p>测试项目中：测试数据及各类监测指标</p><p>测试后：测试报告、用户反馈及公众意见</p></li><li><p>认证原理</p><p>通过哈希操作实现数字消解，运用时间戳存储在区块链中。通过哈希值验证数据完整性，传输过程采用非对称加密技术加密</p></li></ul><p><strong>基于智能合约的沙箱风险预警及审计支持</strong></p><p>智能合约是部署在区块链中的程序代码，一旦条款被处罚，代码自动强制执行。</p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211215104115140.png" style="zoom:50%;" /><ul><li><p>实施方案</p><p>建立联盟区块链，将节点加入区块链网络</p><p>将监管条款、法规要求转换为数字协议规则</p></li><li><p>预警机制报送（基于智能合约）</p><p>金融机构根据监管部门的要求，定期或实时上传审计数据到区块链。在区块链上的所有节点同步数据后，触发智能契约，并自动检测出洗钱、恐怖融资、金融欺诈等异常行为。按照预设的规则进行操作，一旦发现异常，实时定位可疑交易，并利用区块链的可追溯性收集相关历史记录，并将预警信息发送给监管部门。</p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211215104740355.png" alt="image-20211215104740355" style="zoom:50%;" /></li></ul><p><strong>智能监管沙箱平台</strong></p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211215105110400.png" alt="image-20211215105110400" style="zoom:50%;" /><p>该平台最底层是区块链基础设施，包括网络服务、数据存储、权限管理、安全机制、共识算法、智能合约栋，将沙箱测试数据存储在区块链上，利用大数据分析模块对金融科技产品/服务的信息安全性、风险水平、业务连续性及运行状态进行分析评估；最后将分析结果可视化。</p><h1 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h1><h2 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h2><p><strong>沙箱的定义</strong></p><p>计算机领域的一种安全机制，为运行中的程序提供的隔离环境。通常是作为一些来源不可信、具有破坏力或无法判定程序意图的程序提供实验之用（我理解为是一种隔离测试环境）</p><blockquote><p>沙箱万物基于<strong>重定向</strong></p><p>沙箱能够做到让沙箱内软件操作的文件、注册表等路径重定向到其他位置（沙箱指定位置），这样软件本来想操作的资源就不会被访问或者操作，保证资源的安全性。</p></blockquote><p><strong>ICO</strong></p><p>Initial Coin Offering首次币发行，是区块链项目首次发行代币，募集比特币、以太坊等通用数字货币的行为，是一种为加密数字货币/区块链项目筹措资金的常用方式</p><p><strong>沙箱在金融领域的用处</strong></p><p>沙箱允许新型科技公司在其中测试实验，同时大公司为其提供支持，监管单位可以豁免新型科技公司一些法律上的责任，从而解决新型金融公司设计新技术难以监管、大公司不开放自身系统所导致的断层问题</p><p><strong>沙箱模型</strong></p><ul><li><p>监管沙箱（Regulatory Sandbox）</p><p>金融服务公司在模拟控制系统下运行软件，运行数据仅记录在沙箱内，不会记录到真实系统中。在沙箱中的公司可以免受一些监管责任，故可在其中进行测试</p></li><li><p>产业沙箱（Industry Sandbox）</p><p>行业内多公司聚在一起成立的虚拟测试环境，让在产业内的众多公司于同一环境下测试。由于测试环境一致，结果较为客观</p></li><li><p>保护伞沙箱（Umbrella Sandbox）</p><p>与产业沙箱类似，为整个产业服务，具有同一标准。但是其是被金融监管单位授权，由非盈利公司经营</p></li></ul><blockquote><p>参考资料：<a href="https://zhuanlan.zhihu.com/p/30731238">【监管科技】监管科技之沙盒技术详解 - 知乎 (zhihu.com)</a></p></blockquote><h2 id="ACP方法"><a href="#ACP方法" class="headerlink" title="ACP方法"></a>ACP方法</h2><p><strong>平行智能理论</strong></p><p>平行系统是由一个自然现实系统与相应的一个或多个虚拟人工系统组成的系统。通过数据驱动的Descriptive Intelligence、实验驱动的Predictive Intelligence、虚拟-现实交互驱动的Prescriptive Intelligence，平行智能面向具有高度工程复杂性、社会复杂性的CPSS（Cyber-Physical-Social Systems ）为不确定的、多样且复杂问题提供便捷、集中、聚合的解决方案</p><p><a href="https://blog.csdn.net/FnqTyr45/article/details/80190291">(15条消息) 人工智能的本源与展望：从亚里士多德到平行智能_算法与数学之美-CSDN博客</a></p><p><strong>ACP方法</strong></p><p>实现平行智能的有效途径。在ACP方法中，A用于建模和表示，C用于分析和评价，P用于复杂系统优化管理</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MVC、MVP、MVVM模式概念及区别</title>
      <link href="/2021/12/12/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01/"/>
      <url>/2021/12/12/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<p>主要参考博客：<a href="https://www.jianshu.com/p/ff6de219f988">MVC、MVP、MVVM模式的概念与区别 - 简书 (jianshu.com)</a></p><h1 id="Model-View-Controller（MVC）"><a href="#Model-View-Controller（MVC）" class="headerlink" title="Model View Controller（MVC）"></a>Model View Controller（MVC）</h1><blockquote><p><strong>Model–view–controller</strong> (<strong>MVC</strong>) is a <a href="https://en.wikipedia.org/wiki/Software_design_pattern">software design pattern</a>[<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller#cite_note-1">1]</a> commonly used for developing <a href="https://en.wikipedia.org/wiki/User_interface">user interfaces</a> that divide the related program logic into three interconnected elements. This is done to separate internal representations of information from the ways information is presented to and accepted from the user.</p><p>——From wiki</p></blockquote><ul><li><p>即MVC事一种使用模型-视图-控制器设计创建web应用程序的模式：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a0/MVC-Process.svg/800px-MVC-Process.svg.png" alt="img"></p><ul><li><p>模型—应用程序中用于处理应用程序数据逻辑的部分（如数据库)</p><p>通常模型对象负责在数据库中存取数据</p></li><li><p>视图—应用程序中处理数据显示的部分（显示效果如HTML）</p><p>通常视图是依据模型数据创建的</p></li><li><p>控制器—应用程序中处理用户交互的部分（业务逻辑）</p><p>通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。</p></li></ul></li><li><p>特点</p><p>优点：耦合性低、重用性高、生命周期成本低、部署快、可维护性高；</p><p>缺点：无明确定义、增加系统结构和实现复杂性、视图和控制器间过于紧密连接、访问效率低</p></li></ul><h1 id="Model-View-Presenter（MVP）"><a href="#Model-View-Presenter（MVP）" class="headerlink" title="Model View Presenter（MVP）"></a>Model View Presenter（MVP）</h1><p><img src="https://upload-images.jianshu.io/upload_images/15226743-947a7c01f8199148.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/537/format/webp" alt="img"></p><p>在MVP中view通过presenter访问而不直接使用Model，所有交互发生在Presenter内部，实现模型与视图完全分离</p><h1 id="Model-view-viewmodel-MVVM"><a href="#Model-view-viewmodel-MVVM" class="headerlink" title="Model view viewmodel (MVVM)"></a><strong>Model view viewmodel</strong> (MVVM)</h1><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/MVVMPattern.png/500px-MVVMPattern.png" alt="MVVMPattern.png"></p><p>MVC的改进版，将view的状态和行为抽象化。MVVM框架的由来便是MVP（Model-View-Presenter）模式与WPF（Windows Presentation Foundation）结合的应用方式时发展演变过来的一种新型架构框架。</p><blockquote><p>主要参考博客：<a href="https://www.jianshu.com/p/ff6de219f988">MVC、MVP、MVVM模式的概念与区别 - 简书 (jianshu.com)</a></p><ul><li><p>模型</p><p>指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。</p></li><li><p>视图—应用程序中处理数据显示的部分（显示效果如HTML）</p><p>外观显示效果</p></li><li><p>视图模型</p><p><em>视图模型</em>是暴露公共属性和命令的视图的抽象。MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个<em>绑定器</em>。在视图模型中，绑定器在视图和数据绑定器之间进行通信。</p></li><li><p>绑定器</p><p>声明性数据和命令绑定隐含在MVVM模式中。在Microsoft解决方案堆中，绑定器是一种名为<a href="https://links.jianshu.com/go?to=https://baike.baidu.com/item/XAML">XAML</a>的标记语言。绑定器使开发人员免于被迫编写样板式逻辑来同步视图模型和视图。在微软的堆之外实现时，声明性数据绑定技术的出现是实现该模式的一个关键因素。</p></li></ul></blockquote><p>优点：低耦合、可重用性、独立开发、可测试</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>cftool工具初识</title>
      <link href="/2021/12/04/cftool%E5%85%A5%E9%97%A8/"/>
      <url>/2021/12/04/cftool%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>在机房中使用curve fitting tool，了解相关基本信息，可以顺着HELP中的User’s guide依次往下阅读</p><blockquote><p>函数库：</p><p><a href="https://ww2.mathworks.cn/help/curvefit/referencelist.html?type=function&amp;s_tid=CRUX_topnav">https://ww2.mathworks.cn/help/curvefit/referencelist.html?type=function&amp;s_tid=CRUX_topnav</a></p><p>官方文档：</p><p><a href="https://ww2.mathworks.cn/help/curvefit/index.html">Curve Fitting Toolbox Documentation - MathWorks 中国</a></p></blockquote><h1 id="工具栏"><a href="#工具栏" class="headerlink" title="工具栏"></a>工具栏</h1><p><strong>File</strong></p><table><thead><tr><th align="center">选项</th><th>含义</th></tr></thead><tbody><tr><td align="center">Import Data</td><td>数据导入，其中包含数据集的导入以及平滑噪声数据</td></tr><tr><td align="center">Create Session</td><td>创建会话，即创建当前要拟合的东西</td></tr><tr><td align="center">Load Session</td><td>保存当前会话</td></tr><tr><td align="center">Save Session</td><td>保存会话</td></tr><tr><td align="center">Generate M-file</td><td>将当前结果生成.m文件</td></tr><tr><td align="center">Print</td><td>输出</td></tr><tr><td align="center">Print to Figure</td><td>输出为matlab的figure文件</td></tr><tr><td align="center">Close Curve Fitting</td><td>关闭</td></tr></tbody></table><p><strong>View</strong></p><table><thead><tr><th align="center">选项</th><th>含义</th></tr></thead><tbody><tr><td align="center">Prediction Bounds</td><td>预测界限</td></tr><tr><td align="center">Confidence Level</td><td>置信区间设置</td></tr><tr><td align="center">Residuals</td><td>残差？</td></tr><tr><td align="center">Clear Plot</td><td>清空图</td></tr></tbody></table><p><strong>Tools</strong></p><table><thead><tr><th align="center">选项</th><th>含义</th></tr></thead><tbody><tr><td align="center">New Custom Equation</td><td>使用自定义函数模拟图中散点数据的函数</td></tr><tr><td align="center">Legend</td><td>右上角曲线标志</td></tr><tr><td align="center">Grid</td><td>网格线</td></tr><tr><td align="center">Zoom in</td><td>放大</td></tr><tr><td align="center">Zoom Out</td><td>缩小</td></tr><tr><td align="center">Pan</td><td>拖动页面移动</td></tr><tr><td align="center">Axis Limit Control</td><td>调节坐标横纵轴显示</td></tr><tr><td align="center">Default Axis Limits</td><td>恢复初始横纵坐标</td></tr></tbody></table><p><strong>Window</strong></p><p>列表中显示的是当前打开的matlab窗口</p><p><strong>Help</strong></p><p>Curve Fitting Tool Help</p><p>Curve Fitting Toolbox Help：这里可以查看详细指南</p><p>Demos</p><p>About Curve Fitting</p><h1 id="五大按钮"><a href="#五大按钮" class="headerlink" title="五大按钮"></a>五大按钮</h1><table><thead><tr><th align="center">按钮</th><th>功能</th></tr></thead><tbody><tr><td align="center"><strong>DATA GUI</strong></td><td>- 导入、预览、命令、删除数据集<br/>- 平滑噪声数据</td></tr><tr><td align="center"><strong>FITTING GUI</strong></td><td>- 使用库或自定义方程、平滑样式曲线或插值拟合数据<br/>- 检查并比较拟合结果，包括拟合系数值和拟合优度估计<br/>- 持续跟踪当前对话中的所有拟合及相关数据集</td></tr><tr><td align="center"><strong>EXCLUDE GUI</strong></td><td>- 标记从需要拟合中排除的数据<br/>- 查看排除规则</td></tr><tr><td align="center"><strong>PLOTTING GUI</strong></td><td>- 控制在cftool中数据集和拟合的显示</td></tr><tr><td align="center"><strong>ANALYSIS GUI</strong></td><td>- 计算（插值或推断）、区分或合并一种拟合曲线<br/>- 绘制分析结果和数据集</td></tr></tbody></table><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><p>基本命令如下：</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 打开Curve Fitting Tool</span></span><br><span class="line">cftool</span><br><span class="line"><span class="comment">% 查看cftool toolbox中的函数</span></span><br><span class="line">help curvefit</span><br><span class="line"><span class="comment">%打开并编辑对应函数</span></span><br><span class="line">edit [function_name]</span><br><span class="line"><span class="comment">%查看某函数的帮助</span></span><br><span class="line">help [function_name]</span><br><span class="line"><span class="comment">%查看某函数具体文档</span></span><br><span class="line">doc  [function_name]</span><br></pre></td></tr></table></figure><blockquote><p>参考博客：<a href="https://blog.csdn.net/u011181633/article/details/24850223">(10条消息) MATLAB中cftool使用_槛外人的专栏-CSDN博客_cftool</a></p></blockquote><h1 id="曲线拟合类型"><a href="#曲线拟合类型" class="headerlink" title="曲线拟合类型"></a>曲线拟合类型</h1><table><thead><tr><th align="center">Type of fit</th><th>解释</th></tr></thead><tbody><tr><td align="center">Custom Equations</td><td>用户自定义的函数类型</td></tr><tr><td align="center">Exponential</td><td>指数逼近，有2种类型</td></tr><tr><td align="center">Fourier</td><td>傅立叶逼近，有7种类型</td></tr><tr><td align="center">Gaussian</td><td>高斯逼近，有8种类型</td></tr><tr><td align="center">Interpolant</td><td>插值逼近，有4种类型：linear、nearest neighbor、cubic spline、shape-preserving</td></tr><tr><td align="center">Polynomial</td><td>多项式逼近，有9种类型</td></tr><tr><td align="center">Power</td><td>幂逼近，有2种类型</td></tr><tr><td align="center">Rational</td><td>有理数逼近</td></tr><tr><td align="center">Smoothing Spline</td><td>平滑样条</td></tr><tr><td align="center">Sum of Sin Functions</td><td>正弦曲线逼近，有8种类型</td></tr><tr><td align="center">Weibull</td><td>韦伯分布</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于win10的docker+kubernetes+openFaaS环境搭建</title>
      <link href="/2021/12/03/docker+kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2021/12/03/docker+kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>16G内存以下电脑不建议在本机上进行部署！！！！！内存问题，永远的痛</p><ul><li>2021-11-29 了解docker和k8s的基本知识，调研其安装方法</li><li>2021-11-30 完成docker+k8s的基本搭建</li><li>2021-12-01 解决docker总是断开的情况，总结整理笔记</li><li>2021-12-02 OpenFaas安装完毕，初步搭建成功，但发现8G内存不够，真正跑起来困难，遂思考用云服务器进行环境搭建</li></ul><h1 id="写在安装前"><a href="#写在安装前" class="headerlink" title="写在安装前"></a>写在安装前</h1><p><strong>安装方法</strong></p><p>经过前期观察主要有以下几种方式进行环境部署：</p><ul><li><p>单机部署：faasd</p></li><li><p>集群部署：</p><ul><li><p>法1：docker desktop+k8s</p><p>可参考博客：<a href="https://blog.csdn.net/csdnzyb/article/details/106257751">(10条消息) Windows 10 家庭版 安装 docker for Windows（ docker desktop） 详细步骤_Mr.SoftRock的博客-CSDN博客_windows10家庭版安装docker</a></p></li><li><p>法2：docker（WSL）+k8s三件套</p></li><li><p>法3：在虚拟机中安装linux系统（多节点：网络配置）+k8s三件套</p></li></ul></li></ul><p><strong>方法选择及注意事项</strong></p><p>集群部署方面，法1中Hyper-v主要针对的是WIN10的专业版。而由于Hyper-v和Vmware内核冲突，需要在docker使用时进行开关设置：</p><p>使用win+x键，点击Window Powershell（管理员权限），输入命令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bcdedit /set hypervisorlaunchtype off #使用vmware</span><br><span class="line">bcdedit /set hypervisorlaunchtype auto #使用docker for desktop</span><br></pre></td></tr></table></figure><p>每次切换后需要重启电脑服务生效。</p><blockquote><p>参考博客：<a href="https://blog.csdn.net/hanshilong100/article/details/116693203?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">(10条消息) 针对Docker和VMware Workstation冲突，无法共存，最简单的解决办法_hanshilong100的博客-CSDN博客</a></p></blockquote><p>由于电脑内存因素影响，遂放弃法3.故在集群部署方面，我选择方法二，基于WHL搭建docker，其中选择使用docker for windows进行docker的配置与安装。</p><h1 id="WHL配置"><a href="#WHL配置" class="headerlink" title="WHL配置"></a>WHL配置</h1><h2 id="WHL环境搭建"><a href="#WHL环境搭建" class="headerlink" title="WHL环境搭建"></a>WHL环境搭建</h2><p>用管理员权限打开powershell，启用适用于linux的windows子系统（也可在控制面板中使用），执行命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</span><br></pre></td></tr></table></figure><p>重启电脑，在microsoft store中选择下载ubuntu18.04 LTS。</p><h2 id="ubuntu18-04-LTS"><a href="#ubuntu18-04-LTS" class="headerlink" title="ubuntu18.04 LTS"></a>ubuntu18.04 LTS</h2><p>下载完毕后，从window菜单中启动ubuntu18.04 LTS，设置用户名和口令（独立于window账号）</p><ul><li><p>更换软件源并更新软件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用 root 权限登录，后续输入密码</span></span><br><span class="line">sudo -i</span><br><span class="line"></span><br><span class="line"><span class="comment">#接下来备份当前源，输入以下命令</span></span><br><span class="line">cp /etc/apt/sources.list /etc/apt/sources.list.old </span><br><span class="line"></span><br><span class="line"><span class="comment">#这个sources.list文件就是源文件，删除该文件，重新写一个</span></span><br><span class="line">rm /etc/apt/sources.list</span><br><span class="line">vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>复制以下内容，黏贴至sources.list处，之后ESC+wq保存：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricted</span><br><span class="line">  deb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">  deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted</span><br><span class="line">  deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">  deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted</span><br><span class="line">  deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">  deb http://mirrors.aliyun.com/ubuntu/ xenial universe</span><br><span class="line">  deb http://mirrors.aliyun.com/ubuntu/ xenial-updates universe</span><br><span class="line">  deb http://mirrors.aliyun.com/ubuntu/ xenial multiverse</span><br><span class="line">  deb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiverse</span><br><span class="line">  deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">  deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">  deb http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">  deb-src http://archive.canonical.com/ubuntu xenial partner</span><br><span class="line">  deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted</span><br><span class="line">  deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">  deb http://mirrors.aliyun.com/ubuntu/ xenial-security universe</span><br><span class="line">  deb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse</span><br></pre></td></tr></table></figure><p>更新软件镜像源和软件包</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update      <span class="comment">#更新软件源</span></span><br><span class="line">sudo apt upgrade     <span class="comment">#更新软件包</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="docker安装与配置"><a href="#docker安装与配置" class="headerlink" title="docker安装与配置"></a>docker安装与配置</h1><p>一共有两种docker的安装方式，我选择第二种</p><h2 id="docker：方法一（Ubtunus中安装）"><a href="#docker：方法一（Ubtunus中安装）" class="headerlink" title="docker：方法一（Ubtunus中安装）"></a>docker：方法一（Ubtunus中安装）</h2><h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><p>参考官方文档：<a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu | Docker Documentation</a></p><p>直接进行安装，命令如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#删除旧版本</span></span><br><span class="line">sudo apt-get remove docker docker-engine docker.io containerd runc</span><br><span class="line"></span><br><span class="line"><span class="comment">#更新apt包</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment">#安装指令</span></span><br><span class="line">sudo apt-get install \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line">    </span><br><span class="line"><span class="comment">#添加docker官方GPG密钥</span></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line"><span class="comment">#建立仓库</span></span><br><span class="line"> <span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line">  </span><br><span class="line"><span class="comment">#下载docker engine</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>安装结束后，使用：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#开启docker守护进程</span></span><br><span class="line">sudo service docker start</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">docker version</span><br></pre></td></tr></table></figure><p>在查看版本时，出现<a href="https://blog.csdn.net/weixin_42971644/article/details/99870601?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link">(10条消息) Windows 10 的Linux子系统WSL下安装docker_NANIMONO的博客-CSDN博客_wsl 安装docker</a>所示问题，参考该篇博客解决</p><h3 id="docker进入方式"><a href="#docker进入方式" class="headerlink" title="docker进入方式"></a>docker进入方式</h3><p>每次关闭原有管理员WSL界面，重新开启。需要使用管理员权限进入WSL终端，直接进入root用户并直接在root用户启动docker</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo -s <span class="comment">#进入root</span></span><br><span class="line">sudo service docker start <span class="comment">#启动docker</span></span><br></pre></td></tr></table></figure><img src="C:\Users\Rita0914\AppData\Roaming\Typora\typora-user-images\image-20211130171530349.png" alt="image-20211130171530349" style="zoom:50%;" /><p>docker安装参考：</p><p><a href="https://docs.docker.com/engine/install/ubuntu/">Install Docker Engine on Ubuntu | Docker Documentation</a></p><p><a href="https://www.jianshu.com/p/d1b2b4240256">利用window10的Linux子系统实现docker的安装使用 - 简书 (jianshu.com)</a></p><p><a href="https://www.cnblogs.com/LiangSW/p/9842295.html">wsl中使用原生docker - liangshiwei - 博客园 (cnblogs.com)</a></p><p>docker安装问题：</p><p><a href="https://blog.csdn.net/weixin_42971644/article/details/99870601?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2~default~CTRLIST~default-1.no_search_link">(10条消息) Windows 10 的Linux子系统WSL下安装docker_NANIMONO的博客-CSDN博客_wsl 安装docker</a></p><h2 id="docker：方法二（Docker-for-Windows）"><a href="#docker：方法二（Docker-for-Windows）" class="headerlink" title="docker：方法二（Docker for Windows）"></a>docker：方法二（Docker for Windows）</h2><p><strong>docker for windows下载</strong></p><p>docker for windows官网下载链接：<a href="https://link.zhihu.com/?target=https://www.docker.com/get-started">https://www.docker.com/get-started</a></p><p>安装完毕后，使用管理员权限启动，不要开启k8s（由于默认源未更换），查看docker中kubernetes对应版本为v.1.21.5</p><p><strong>更换默认源</strong></p><p>进入后点击设置图标，找到Docker Engine，将框中内容用如下内容进行替换，点击应用重启键</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;debug&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;experimental&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;insecure-registries&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;https://registry.docker-cn.com&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考博客：<a href="https://zhuanlan.zhihu.com/p/163558476">windows10 部署 docker+k8s 集群 - 知乎 (zhihu.com)</a></p></blockquote><h1 id="Kubernetes环境搭建"><a href="#Kubernetes环境搭建" class="headerlink" title="Kubernetes环境搭建"></a>Kubernetes环境搭建</h1><blockquote><p><a href="https://www.kancloud.cn/docker_practice/docker_practice/2002058">在 Docker Desktop 使用 · Docker —— 从入门到实践 · 看云 (kancloud.cn)</a></p><p>该网址中给出了三种部署kubernetes集群的方式，可以参考</p></blockquote><p><strong>kubernetes镜像下载</strong></p><p>镜像网址：<a href="https://github.com/AliyunContainerService/k8s-for-docker-desktop">https://github.com/AliyunContainerService/k8s-for-docker-desktop</a></p><p>根据kubernetes对应版本为v.1.21.5，需要用到以下命令下载镜像：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://codechina.csdn.net/mirrors/AliyunContainerService/k8s-for-docker-desktop.git</span><br><span class="line">git checkout v1.21.5</span><br><span class="line">git pull origin v1.21.5</span><br></pre></td></tr></table></figure><p><strong>镜像加载</strong></p><p>进入对应下载目录，使用管理员权限打开Powershell，执行指令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.\load_images.ps1</span><br></pre></td></tr></table></figure><blockquote><p>若遇到错误：无法加载文件…，因此在此系统上严禁运行脚本，则键入以下命令后再次执行指令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure></blockquote><p>在命令行中输入docker images，可看到镜像</p><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211130205749047.png" alt="image-20211130205749047"></p><p><strong>启动kubernetes</strong></p><p>在docker desktop的设置中将勾选项都选上，点击应用重启键</p><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211130205827222.png" alt="image-20211130205827222"></p><p><strong>验证Kubernetes集群状态</strong></p><p>cmd中执行如下命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看集群信息</span></span><br><span class="line">kubectl cluster-info</span><br><span class="line"><span class="comment">#查看节点信息</span></span><br><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211130205807810.png" alt="image-20211130205807810"></p><p><strong>Kubernetes控制台配置</strong></p><p>在下载目录中，执行命令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create -f kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211130210346703.png" alt="image-20211130210346703"></p><p><strong>登录Kubernetes</strong></p><p>启动API Server访问代理，执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure><p>浏览器中访问Kubernetes Dashboard，网址如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</span><br></pre></td></tr></table></figure><p>配置控制台访问令牌，使用token方式登录，在命令行键入如下命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get secret -n=kube-system</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#根据NAME获取相应的TOKEN</span><br><span class="line">kubectl describe secret -n=kube-system [default-token-scxs5] #[]中是name</span><br></pre></td></tr></table></figure><p>记住token后面的值，把下面的token值复制到浏览器token登陆处即可登陆</p><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211130215953687.png" alt="image-20211130215953687"></p><p><strong>限制WSL内存</strong></p><p>在登录后，总是断开连接，提示信息如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker Desktop WSL 2 backend has stopped unexpectedly. Do you want to restart it?</span><br></pre></td></tr></table></figure><p>解决方法如下：</p><p>按win+R键，调出运行对话框，输入”%UserProfile%”，点击确认进入用户目录，新建”.wslconfig“文件，限制WSL2内存大小为4G，添加内容如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">memory=4GB</span><br><span class="line">swap=0</span><br><span class="line">localhostForwarding=true</span><br></pre></td></tr></table></figure><p>运行正常，安装成功</p><blockquote><p>参考博客：</p><p><a href="https://blog.csdn.net/weixin_41915314/article/details/113619475">(10条消息) 在Docker Desktop中安装Kubernetes_wifiiii的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/zhang6318/article/details/118767126">(10条消息) Win10 Docker Desktop_自由软件的天堂-CSDN博客</a></p></blockquote><h1 id="OpenFaaS安装"><a href="#OpenFaaS安装" class="headerlink" title="OpenFaaS安装"></a>OpenFaaS安装</h1><p>参考博客：</p><p><a href="https://xinchen.blog.csdn.net/article/details/109805296">(11条消息) OpenFaaS实战之一：部署_程序员欣宸的博客-CSDN博客_openfaas</a></p><p><a href="https://blog.kaixindeken.top/archives/16">https://blog.kaixindeken.top/archives/16</a></p>]]></content>
      
      
      <categories>
          
          <category> 无服务器运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于区块链的智慧城市银行税务交互系统</title>
      <link href="/2021/12/01/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82%E9%93%B6%E8%A1%8C%E7%A8%8E%E5%8A%A1%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F/"/>
      <url>/2021/12/01/%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%99%BA%E6%85%A7%E5%9F%8E%E5%B8%82%E9%93%B6%E8%A1%8C%E7%A8%8E%E5%8A%A1%E4%BA%A4%E4%BA%92%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>文献提出一种基于HyperLedger结构区块链的智慧城市银行税交互系统，解决企业、税务局和银行之间的企业税务数据共享和业务连接问题。</p><span id="more"></span><ul><li>2021-11-29 初步浏览论文，通读文献第1节，对论文涉及到的背景知识进行学习。对其中提到的贡献需要根据后续进一步阅读文献进行理解修正，超级账本的参考博客还未通读</li><li>2021-11-30 阅读文献第2节，下一步是看看系统的实现效果，针对区块链和智能合约基础知识，想出一篇较为详细的笔记</li><li>2021-12-1 初步阅读完文献，可以对该文献中涉及到的基础知识进行学习后，再次阅读该文献。</li></ul><p>对于知识扩展部分的区块链和智能合约等内容，后期想出一篇单独的md进行详细记录（区块链、HyperLedger’s fabric blockchain、智能合约）</p><h1 id="信息概述"><a href="#信息概述" class="headerlink" title="信息概述"></a>信息概述</h1><h2 id="论文标题"><a href="#论文标题" class="headerlink" title="论文标题"></a>论文标题</h2><p>Bis: A Novel Blockchain based Bank-tax Interaction System in Smart City </p><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><p> 区块链、智慧城市、税务数据、银行税交互</p><h2 id="研究问题"><a href="#研究问题" class="headerlink" title="研究问题"></a>研究问题</h2><p>中国的小微企业占据大量市场，但却面临着困难、复杂的融资问题。同时，银行向小微企业放贷时，面临信贷成本较高、风险控制困难的问题。区块链作为一种为金融和非金融交易创建和维护加密安全、共享和分布式账本的技术，为数字交易带来了信任、问责制和透明度。如何进行安全有效的数据输入、请求和传输，完成各方业务和功能是区块链系统需要解决的问题。</p><h2 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h2><p>文献提出一种基于HyperLedger结构区块链的智慧城市银行税交互系统，解决企业、税务局和银行之间的企业税务数据共享和业务连接问题。具体贡献如下：</p><ol><li>提出一种基于区块链技术的新型银行税交互模型，以确保组织间银行税交互业务系统中税的相关数据的开放性。</li><li>选择企业区块链系统结构开发原型系统</li><li>利用企业级商用区块链网络构建联盟链，以提高区块链网络的安全性和可靠性</li></ol><h1 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h1><h2 id="Bis的设计"><a href="#Bis的设计" class="headerlink" title="Bis的设计"></a>Bis的设计</h2><p><strong>说明</strong></p><p>基于区块链技术搭建分布式、可信赖的银行税交互模型，利用区块链开源系统Fabric实现原型系统，并对提出模型效果进行验证</p><p>总目标：实现安全有效的数据输入、请求和传输，完成各方业务功能</p><p><strong>总体架构</strong></p><p>区块链中有三个组织机构：银行、税务局、CBRC。在其中间建立渠道，使其实现银行和税务的合作机制。</p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211130101539194.png" style="zoom:50%;" /><p><strong>优势</strong></p><ul><li>多中心（去中心化）：区块链每个节点有完整账本数据，多组织之间的账本数据实时共享</li><li>可靠性：数据存储于区块链每个节点中。一个节点被破坏时，整个系统数据不受影响</li><li>鲁棒性：数据分布在多节点上</li><li>开放性：降低数据披露成本</li><li>高效：智能合约自主运行，其本身无法被篡改</li><li>安全：交易使用数字签名确保不拒付</li></ul><p><strong>加解密方法</strong></p><p>使用对称加密算法加密税务相关数据。使用公钥加密对称密钥，公钥和已加密税务相关数据的存储在链中，已授权的银行可通过私钥解密获得对称密钥以解密税务相关数据。</p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211130103011156.png" style="zoom:50%;" /><p><strong>数据存储结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211130103813659.png" alt="image-20211130103813659" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211130103839146.png" alt="image-20211130103839146" style="zoom:33%;" /><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211130104553023.png" style="zoom:33%;" /></p><ul><li><p>区块链数据写入</p><p>通过Java SDK控制链码写入数据。每个数据字段的java代码格式与底层连代码一致。即，公司在税务局网站存入税务相关数据后可以在银行税务互动网站找到授权银行查找税务相关信息</p></li><li><p>区块链数据获取</p><p>某企业登录银行网站申请贷款，通过java SDK在链中读取已加密税务数据和已加密公钥，通过银行的私钥解密已加密公钥，再解密相关信息</p></li><li><p>基于区块链的信用结构反馈查询</p><p>BRC查询信任信息时，提供私钥进行请求，Java SDK返回非对称加密信息，这部分与区块链数据获取信息步骤相似</p></li></ul><p><strong>链码调用与查询函数实现</strong></p><ul><li><p>过程</p><p>程序调用javasdk将参数传递给链码，所有参数传递给函数Invoke。该函数将调用其他函数以根据参数完成对应函数。同时该链码提供不同查询方式。</p><p>下表中是主要函数及其功能：</p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211130110828877.png" alt="image-20211130110828877" style="zoom:50%;" /></li><li><p>数据交互功能实现</p><ul><li>写入、查询税务信息</li><li>写入、查询信用信息</li></ul></li><li><p>主要函数逻辑</p></li></ul><h2 id="Bis的实现和部署"><a href="#Bis的实现和部署" class="headerlink" title="Bis的实现和部署"></a>Bis的实现和部署</h2><ul><li><p>公共对等节点配置</p><p>使用三台虚拟机进行模拟，公共对等节点配置示例如下：</p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211201100421917.png" style="zoom:50%;" /><p>使用Fabric部署区块链系统，以实现良好可伸缩性和负载平衡</p></li><li><p>区块链参数配置</p><p>通过在网站上提供数据源接口和数据表示查询接口，区块链系统可以通过结构的结构sdk与其他组件对接，实现数据流和功能集成。</p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211201100942538.png" style="zoom:50%;" /></li><li><p>订购服务节点组织配置</p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211201101008120.png" style="zoom:50%;" /></li><li><p>区块与通道的配置</p><p>每个主机上有6个对等节点和6个CouchDBs</p><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/image-20211201101036806.png" alt="image-20211201101036806"></p></li></ul><h1 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h1><h2 id="区块链-Blockchain"><a href="#区块链-Blockchain" class="headerlink" title="区块链(Blockchain)"></a>区块链(Blockchain)</h2><blockquote><p><strong>比特币 知识扩展</strong></p><ul><li>交易单位为比特币（BTC）</li><li>事实交易支付：任何一笔交易的前提是付款方的比特币账户中有足够的比特币用于支付；且每笔交易不以余额为基础，以之前的交易为基础</li><li>比特币账户：以字符串代表账户，保证隐私性</li><li>比特币系统核心思想：用算力限制区块的生成速度</li></ul><p>论文扩展：</p><p>比特币之父（中本聪）2008 Bitcoin：A Peer-to-Peer Electronic Cash System </p><p>论文链接：<a href="https://bitcoin.org/bitcoin.pdf">bitcoin.pdf</a></p></blockquote><p><strong>定义</strong></p><p>区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式，其本质是去中心化的数据库。区块链是比特币的底层技术，是一串使用密码学方法相关联产生的数据块。每一个数据块中包含了一批次比特币网络交易的信息，用于验证其信息的有效性和生成下一个区块。</p><p><strong>特征</strong></p><p>去中心化、开放性、自治性、信息不可篡改、匿名性</p><p><strong>区块结构</strong></p><p>区块中包含区块头和区块体：</p><img src="https://www.runoob.com/wp-content/uploads/2018/02/img_24.jpg" alt="img" style="zoom:50%;" /><blockquote><p>参考博客：</p><p><a href="https://www.runoob.com/w3cnote/carton-blockchain-intro.html">漫画解析：谁叫的区块链，来门口取一下！ | 菜鸟教程 (runoob.com)</a></p><p><a href="https://www.runoob.com/w3cnote/blockchain-intro.html">区块链入门教程 | 菜鸟教程 (runoob.com)</a></p></blockquote><h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><p><strong>定义</strong></p><p>是一种旨在以信息化方式传播、验证或执行合同的计算机协议。智能合约于1995年由Nick Szabo提出，允许在没有第三方的情况下进行可信交易，这些交易可追踪且不可逆转。</p><p>Nick Szabo给出的定义是：一个个智能合约是一套以数字形式定义的承诺，包括合约参与方可以在上面执行这些承诺的协议</p><p><strong>以太坊智能合约技术</strong></p><blockquote><p>参考链接：<a href="https://github.com/EthFans/wiki/wiki/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6">智能合约 · EthFans/wiki Wiki (github.com)</a></p></blockquote><p>简易智能合约模型如下：</p><img src="https://camo.githubusercontent.com/537c6751480186e047c7d15359043dac3e090f076d861468b772afc0225153b5/687474703a2f2f65746866616e732e6f72672f75706c6f6164732f70686f746f2f323031352f66313737313863653037376335316465653037373432373534396634363938322e706e67" alt="3" style="zoom:50%;" /><p>一段代码（智能合约），被部署在分享的、复制的账本上，它可以维持自己的状态，控制自己的资产和对接收到的外界信息或者资产进行回应。</p><p>智能合约模型是运行在可复制、共享的账本上的计算机程序，可以处理信息，接收、储存和发送价值。</p><h2 id="边缘计算-edge-computing-oriented"><a href="#边缘计算-edge-computing-oriented" class="headerlink" title="边缘计算(edge-computing-oriented)"></a>边缘计算(edge-computing-oriented)</h2><p><strong>定义</strong></p><p>边缘计算是一种分散式运算的架构，将原本完全由中心节点处理大型服务加以分解，切割成更小且容易管理的部分，分散至边缘节点处理。</p><blockquote><p>参考博客：</p><p><a href="https://www.jianshu.com/p/81414823d05b">通俗讲解边缘计算 - 简书 (jianshu.com)</a></p></blockquote><h2 id="超级账本-Hyperledger-Fabric"><a href="#超级账本-Hyperledger-Fabric" class="headerlink" title="超级账本(Hyperledger Fabric)"></a>超级账本(Hyperledger Fabric)</h2><p><strong>介绍</strong></p><p>Hyperledger Fabric 是分布式账本解决方案的平台，采用模块化架构，提供高安全性、弹性、灵活性和可扩展性。它被设计为支持以可插拔方式实现不同组件，并适应复杂的经济生态系统。</p><blockquote><p>参考博客：</p><p><a href="https://linux.cn/article-11328-1.html">技术|Hyperledger Fabric 介绍 (linux.cn)</a></p></blockquote><h2 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h2><p><strong>链码（chaincode）</strong></p><p>链码就是所谓的智能合约。智能合约是由事件驱动的，具有状态的存储和运行在区块链上的程序。它通过预置了一些条件和规则，在一定的事件下触发智能合约的执行。智能合约最终的目标是在区块上生成账本数据，也就是说所有对账本的操作都是由智能合约来完成的。</p><p><strong>java sdk</strong></p><p>软件开发包，是厂商提供的集成封装的库，通用性强。SDK是开发java应用程序所必须的，其他编程框架和类库都建立在它们之上。</p><p><strong>AES-GCM</strong></p><p>GCM ( Galois/Counter Mode) 指的是该对称加密采用Counter模式，并带有GMAC消息认证码。</p><blockquote><p>参考链接：<a href="https://juejin.cn/post/6844904122676690951">AES-GCM 加密简介 - 掘金 (juejin.cn)</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习解决多人零和博弈中的联盟困境</title>
      <link href="/2021/11/25/%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0%E8%A7%A3%E5%86%B3%E5%A4%9A%E4%BA%BA%E9%9B%B6%E5%92%8C%E5%8D%9A%E5%BC%88%E4%B8%AD%E7%9A%84%E8%81%94%E7%9B%9F%E5%9B%B0%E5%A2%83/"/>
      <url>/2021/11/25/%E7%AC%94%E8%AE%B0-%E5%AD%A6%E4%B9%A0%E8%A7%A3%E5%86%B3%E5%A4%9A%E4%BA%BA%E9%9B%B6%E5%92%8C%E5%8D%9A%E5%BC%88%E4%B8%AD%E7%9A%84%E8%81%94%E7%9B%9F%E5%9B%B0%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<p>该文献中通过列举symmetric three-player two-action matrix games和sequential-move games两个实例，证明联盟困境的存在以及该情况下基于梯度学习的失败，提出一种绑定合同机制以帮助多智能体学会联盟，同时针对该合同机制进行扩展：增加时间限制和惩罚。</p><span id="more"></span><ul><li>2021-11-20 选定阅读论文</li><li>2021-11-21 初步阅读论文，提取研究问题及相关贡献</li><li>2021-11-22 精细阅读第1、2节相关内容，其中马尔可夫策略下的多智能体学习方法有待进一步深化，第3节已大致浏览，下一步将针对两个实例进行具体阅读和学习</li><li>2021-11-23 阅读完第3节相关内容，看到4.1节。其中智能体的神经网络构造、图8中的相关系数、补充概念中的几个知识点记得探究</li><li>2021-11-24 阅读完全篇论文，有些思路没有理清，需要带着问题再反复思考思考</li></ul><h1 id="信息概述"><a href="#信息概述" class="headerlink" title="信息概述"></a>信息概述</h1><table><thead><tr><th align="center"><div style="width: 150rpx"> 论文标题</div></th><th align="left">学习解决多人零和博弈中的联盟困境<br>《Learning to Resolve Alliance Dilemmas in Many-Player Zero-Sum Games》</th></tr></thead><tbody><tr><td align="center"><strong>关键词</strong></td><td align="left">深度强化学习、多智能体学习、协商、联盟形成（策略）</td></tr><tr><td align="center"><strong>研究问题</strong></td><td align="left">对多人零和游戏的系统研究是人工智能研究的一个关键因素。多人零和游戏中联盟的形成能够带来优势，尚不成熟的多智能体强化学习无法形成联盟。该文献中利用对称零和博弈证明多人零和博弈中存在的联盟困境；引入经济竞争的玩具模型（toy model），通过点对点合同机制增强强化学习用以发现和形成联盟；并将智能体模型纳入临时扩展合同用以进一步研究工作。</td></tr><tr><td align="center"><strong>贡献</strong></td><td align="left">- 引入联盟困境的概念，从数学上定义联盟形成的挑战 <br>- 证明目前最先进的强化学习在双人零和游戏中发挥强大作用，但未形成联盟 <br>- 为RL智能体形成联盟提供一个简洁且具有积极性的合同机制</td></tr></tbody></table><h2 id="证明联盟困境"><a href="#证明联盟困境" class="headerlink" title="证明联盟困境"></a>证明联盟困境</h2><p>该文献中通过列举symmetric three-player two-action matrix games和sequential-move games两个实例，证明联盟困境的存在以及该情况下基于梯度学习的失败，</p><h2 id="合同"><a href="#合同" class="headerlink" title="合同"></a>合同</h2><p>文献中提出一种绑定合同机制以帮助多智能体学会联盟，同时针对该合同机制进行扩展：增加时间限制和惩罚。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>单一环境。该文献提出的方法仅在简单环境下实验，而真实情况下联盟困境可能出现在由不同玩家具有不同策略的条件下，这方面该方法的优越性尚不可知；</p><p>文中提到symmetric zero-sum matrix games，中文翻译为对称零和矩阵博弈，而矩阵博弈是典型的非零和博弈，应该是翻译的理解上存在一些问题，这里的矩阵指的应该是结构</p><h1 id="阅读笔记"><a href="#阅读笔记" class="headerlink" title="阅读笔记"></a>阅读笔记</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>零和游戏中的 <em>Minimax theorem</em></strong></p><p>理解参考：<a href="https://zhuanlan.zhihu.com/p/344062337">博弈论笔记(九)：二人零和博弈 - 知乎 (zhihu.com)</a></p><p>双人零和博弈三个特点</p><ol><li>提供衡量算法性能的明确方法</li><li>提供直观的复杂性度量，能够为研究提供困难度排序</li><li>极小极大值定理和纳什策略得到的结果一致，故原则上不需要适应他人策略</li></ol><p><strong>双人零和游戏的局限性</strong></p><p>真实情况下人与人之间的互动常常包括着合作与竞争。双人零和游戏仅从理性的角度考虑，未考虑到真实环境具备的混合动机以及人类复杂的社会属性对动机和选择的影响。</p><ul><li><p>图一</p><p>双人零和游戏中每个玩家的收益都在0-1之间，如果双人收益和也在0-1之间成为epsilon常数和。作者进行1000次双人双动作随机游戏的直方图，纵坐标代表epslion常数和，横坐标代表epslion的值。</p><p>结论：趋于0的位置密度较低且呈三角形分布；这说明真实情况下零和博弈很是罕见</p><blockquote><p>扩展知识：Epslion-Equilibrium</p><p>参考资料: <a href="https://wiki.mbalib.com/wiki/%CE%95-%E5%9D%87%E8%A1%A1">Ε-均衡 - MBA智库百科 (mbalib.com)</a></p><p><strong>epsilon 递减策略 （epsilon-decreasing strategy）</strong>：这种强化学习技术用于分配资源，它包括两个彼此交叉的阶段：探索阶段和利用阶段。 epsilon 指探索时间与总时间的比例，随着最佳方案的相关信息越来越多，epsilon 值逐渐减小。</p></blockquote></li></ul><p>故双人零和游戏只是在探究多智能体学习的一个起点，我们需要进一步探究细节。</p><p><strong>多智能体合作方法</strong></p><ul><li><p>方法一：两智能体团队之间的零和游戏</p><p>每个团队面临内部协调问题，未解决团队战略层面的局限性，且团队的固定使得个体面临组队问题</p></li><li><p>方法二：打破零和限制</p><p>通过学习智能体以适应和塑造他们的合作者的学习，从而使得在不被利用的情况下实现协调与合作。但该方法缺乏对多智能体性能的规范度量，使得算法与算法之间的合作变得困难</p></li><li><p>方法三：给定的情景下进行工作调查合作</p><p>以消除对抗性的动态因素作为代价实现</p></li><li><p>方法四：优化可利用对手在固定背景下的最大优势</p><p>即，稳健最佳反应学习已取得进展。但是选择背景对手的必要性消除1、2点提到的一些优势</p></li></ul><p><strong>贡献</strong></p><p>关注于多玩家零和游戏的联盟形成问题，证明这类游戏中的联盟会产生社会困境且标准的独立强化学习智能体无法学习形成联盟。故提出用以增强学习智能体的简单协议，允许智能体学习点对点合同以使其建立联盟，通过一个经济竞争的玩具模型研究该协议的影响，证明合同增强智能体的优越性。同时，以通过惩罚执行的方式对模型进行扩展</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p><strong>相关工作</strong></p><p>目前在没有人类数据的情况下学习形成持久、适应性强的联盟的问题仍然存在，在该领域没有工作明确如何解决联盟形成的问题</p><p>该文献基于在竞争环境中协调智能体的方法，是第一个在该情况下应用MARL的工作，并展示允许MARL智能体形成联盟具体协议的有效性</p><p>该文献提出的MARL方法增强智能体就未来行动进行谈判、形成合同的能力</p><p><strong>多智能体强化学习（MARL）</strong></p><ul><li><p>马尔可夫博弈中的MARL</p><blockquote><p>扩展理解：</p><p><a href="https://www.cnblogs.com/suancai/p/15332556.html">多智能体博弈强化学习研究综述笔记1 - 一丨 - 博客园 (cnblogs.com)</a></p><p>多智能体马尔可夫决策过程：当智能体的数量超过一个，同时环境的改变和每个智能体的回报取决于所有智能体的动作和当前状态。</p><p>给定现有状态时，其与过去状态是条件独立的，即此随机过程具有马尔可夫性质；</p><p>MDP包含一组交互对象：智能体和环境</p><ul><li>智能体：MDP中进行机器学习的智能体，可以感知外界环境的状态进行决策、对环境做出动作并通过环境的反馈调整决策。</li><li>MDP模型中智能体外部所有事物的集合，其状态会受智能体动作的影响而改变，且上述改变可以完全或部分地被智能体感知。环境在每次决策后可能会反馈给智能体相应的奖励。</li></ul></blockquote></li><li><p>论文设置</p><p>每个智能体包括一个前馈神经网络模块和递归模块，以单个观察结果作为输入，策略日志和值估计作为输出；</p><p>采用<em><strong>advantage actor-critic（A2C）</strong></em>策略梯度方法训练智能体，该方法使用IMPALA框架扩展</p></li></ul><h2 id="联盟困境"><a href="#联盟困境" class="headerlink" title="联盟困境"></a>联盟困境</h2><p><strong>社会困境</strong></p><table><thead><tr><th align="center"></th><th align="center"><strong>A合作</strong></th><th align="center"><strong>A背叛</strong></th></tr></thead><tbody><tr><td align="center"><strong>B合作</strong></td><td align="center">R,R</td><td align="center">S,T</td></tr><tr><td align="center"><strong>B背叛</strong></td><td align="center">T,S</td><td align="center">P,P</td></tr></tbody></table><blockquote><p>充要条件：</p><ul><li><p><em>R &gt; P</em>：双方合作比双方背叛好；</p></li><li><p><em>R</em> &gt; <em>S</em>：双方合作优于被叛逃者利用；</p></li><li><p><em>T &gt; R, P &gt; S</em>：在对方固定选择时，背叛比合作损失小</p></li><li><p>2<em>R</em> &gt; <em>T</em> + <em>S</em>：双方合作优于叛逃和合作的组合（有争议，为严格要求）</p></li></ul></blockquote><p>从联盟角度而言，前三个条件为重要条件</p><p><strong>多玩家零和博弈</strong></p><p>n玩家双动作零和博弈：任何玩家效用收益与其他玩家效用损失完全平衡</p><p>在k（k&lt;n）玩家形成联盟时，帕累托存在改进可能</p><p><strong>联盟困境</strong></p><p>联盟困境是当其他玩家处于某一状态时，玩家i和j面临的社会困境</p><p>文献通过两个实例证明基于梯度的学习在联盟困境存在下无法达到合理结果</p><h3 id="实例1-Counting-alliance-dilemmas"><a href="#实例1-Counting-alliance-dilemmas" class="headerlink" title="实例1 Counting alliance dilemmas"></a>实例1 Counting alliance dilemmas</h3><p>对于3个玩家2个动作的零和游戏，进行预测：</p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211125_1.png" alt="1" style="zoom:80%;" /><p>共进行1000次实验，发现54%包含联盟困境，12%为严格联盟困境。</p><ul><li><p>图二：联盟困境在p-q空间上的分布  图三</p><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211125_2.png" alt="2" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211125_3.png" alt="3" style="zoom: 80%;" /></p><p>横坐标代表的是顽固智能体的政策，纵坐标是社会困境的产生数量，发现随着“顽固”智能体的政策趋于确定性时（趋于0或趋于1时），联盟困境变得更加普遍</p></li></ul><p><strong>基于梯度学习的失败</strong></p><blockquote><p>情况A（单打独斗）：$$p=1,q=0$$  只有当行为为1且完全与其他两位不同时，才能赢得游戏</p><p>情况B（匹配）：$$p=0,q=1$$  只有当行为为1且完全与其他两位不同时，才会输掉游戏</p><p>前者（情况A）存在非严格的贪婪性困境（由收益实现可能性产生）；后者（情况B）存在严格的恐惧性困境（避险心理）</p></blockquote><ul><li><p>图四：上述两种情况基于梯度学习的学习动态</p><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211125_4-1.png" alt="4-1" style="zoom: 67%;" /><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211125_4-2.png" alt="4-2" style="zoom: 67%;" /></p><p>图中的直线是智能体在具有相同学习速率的softmax策略梯度下的轨迹，情况B中多智能体均学会匹配顽固智能体；而情况A中两个智能体都没学会如何匹配。</p><ul><li><p>说明</p><p>匹配联盟中最佳解决方法是采取和顽固智能体相反的动作以获得$$\frac{1}{2}$$的回报；</p><p>而所有初始化的策略都收敛于两者采取与顽固智能体相同的行动以获得$$\frac{1}{3}$$的回报</p></li><li><p>情况A</p><p>最优对称联盟方案是每个阶段中$$\frac{3}{4}$$与顽固智能体选择相同，平均回报为$$\frac{3}{8}$$</p></li></ul><p>结论：面对具有确定性策略的顽固智能体时，基于梯度的学习无法找到联盟：</p><p>1）系统的学习动态趋向于一个固定点，在这个点上两个智能体永远不会适应顽固智能体，故得不到任何奖励</p><p>2）学习对代理初始状态和学习速率高度敏感，微小差异会导致轨道的巨大变化</p><blockquote><p><u>文中提到附录中有数学推导，但是没有找到附录</u></p></blockquote></li></ul><h3 id="实例2-Gifting-an-alliance-dilema"><a href="#实例2-Gifting-an-alliance-dilema" class="headerlink" title="实例2 Gifting: an alliance dilema"></a>实例2 Gifting: an alliance dilema</h3><p>关注于序贯决策博弈，实例如下：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n个玩家在初始状态下都有m个自己颜色的筹码。轮到该玩家时，需要送出一枚自己的筹码或者选择丢弃一枚筹码。当没有玩家有自己颜色的筹码时游戏结束（n*m回合后）。赢家是拥有最多筹码的玩家，存在平局现象。获胜者收益平均为1，其余玩家收益为0.</span><br></pre></td></tr></table></figure></blockquote><p>该博弈可被解释为基于稀缺商品分配的经济竞争玩具模型 </p><ul><li><p>图五</p><p>每个玩家轮流玩1次游戏。玩家0送给玩家2一个筹码；玩家1丢弃了一个黄色筹码；玩家2送给玩家0一个红色筹码</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211125_5.png" alt="5"></p><p>博弈情况分析：</p><p>“每个玩家选择丢弃”能够达到子问题完美纳什均衡，否则就是以牺牲自己为代价满足他人；</p><p>两个玩家交换芯片，实现双向平局，而非三方平局；</p><p>故存在联盟困境：两个玩家相互信任可以联盟获得更好的结果，但是只有一方背叛可以从中获益。</p><ul><li><p>图6：MARL未能收敛证明这种交易行为的政策</p><blockquote><p>智能体的神经网络构造</p><p>智能体被随机分配到 1、2 或 3 号座位，因此必须根据播放顺序进行概括。</p><p> 每个智能体的神经网络包括一个具有两层 128 个处理单元的 MLP，然后是一个具有 128 个处理单元的 LSTM。 策略和价值头是 LSTM 之上的线性层。 我们通过反向传播进行训练，使用等于事件长度的展开长度。 使用 RMSProp 优化器进行优化，衰减为 0.99，动量为 0，epsilon 为 0.001，学习率为0.000763。 该策略的熵成本为 0.001443。 我们执行使用 10 个不同随机种子初始化的训练运行，并以 95% 的置信区间绘制平均值。 </p></blockquote><p>在该游戏环境下MARL的学习曲线，A-C（纵坐标依次为奖励、丢弃、赠送）图中是三个独立的学习者迅速收敛到不给予的完美纳什平衡，导致三方平局；</p><p>D-F图中是一个玩家被复制机器人所取代（该机器人总模仿learner0的行为），此时learner0知道要赠送礼物，因为必会得到回报，最终达到两人平局。而learner1最初学会丢弃，但是发现不会提供额外奖励后，熵正则化器会导致所选择动作的随机波动</p></li></ul><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211125_6.png" alt="6" style="zoom:67%;" /><p><strong>得到结论</strong></p><p>强化学习在已有支持合作行为下是可适应的，但是MARL无法做出出不信任联盟中所必须的互惠行为</p><h2 id="合同-1"><a href="#合同-1" class="headerlink" title="合同"></a>合同</h2><p><strong>约束合同</strong></p><p>提出一种点对点的能合并到MARL中的完整合同。</p><p>合同渠道增强核心环境：</p><p>每时间段内，每个玩家i需要提交一份合同报价，其中包括对合伙人j的选择、对合伙人j的建议、以及自己承诺需要采取的行动，或没有合同。若两者提供相同合同，则该合同具有约束力；</p><p>环境通过提供相关智能体向量的掩膜（mask）强制执行已承诺的行动（感觉有点身份认证的意思）。每一步中，智能体会收到对最后一个时段提供合同的观察，编码为独热表示</p><p><strong>有合同意识的MARL</strong></p><ul><li><p>概念解释</p><p>采用具有2个策略头（head）的神经网络，一个用于核心环境，一个用于合同渠道。</p><p>输入：核心环境状态+前一时段的合同；根据来自核心环境的奖励，使用A2C算法对两个头（head）进行训练。智能体在学习如何在环境中表现得同时，学习如何利用具有约束力得协议与其他玩家更好协调</p></li><li><p>实验结果</p><blockquote><p>合同神经网络在前面的基础上增加线性合同头。合同策略中包含熵正则化器，其中训练和评价方法与基本实验相应</p></blockquote><ul><li><p>图7</p><p>实验1（A-C：奖励、丢弃、已签订合同）：训练2个合同增强（contract-augmented）智能体和1个A2C机器人。图中learner0和learner1为合同增强机器人，learner2为A2C机器人</p><blockquote><p>两个合同增补代理能够实现2路平局，淘汰不能签订合同的代理。 </p></blockquote><p>实验2（D-F：奖励、丢弃、已签订合同）：训练3个合同增强机器人。</p><blockquote><p>随着代理商竞争签订合同以保证他们更多的礼物，丢弃的数量减少，签订的合同数量增加</p></blockquote><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211125_7.png" alt="7" style="zoom:67%;" /></li><li><p>图8：证明签定合同与在游戏中积累更多筹码具有显著相关性，签约是有利的</p><p>培训后进行50场比赛，记录每个玩家的筹码总书和签订合同数，线性回归显示呈正相关</p><p>Q：参数R和P是什么？</p><p>是回归方程中的相关系数，可以看到相关系数R是0.49，故表面两个变量呈正相关</p></li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211125_8.png" alt="8" style="zoom:50%;" /><p><strong>具有时限的合同</strong></p><p>扩展：签署合同后，智能体需要在b时间范围内采取已承诺行为；否则违反合同并获得相关负面奖励r<sub>c</sub>；合同破裂后，智能体可签署新合同；</p><ul><li><p>Trembling hand策略</p><p>从零开始学会签署惩罚-强制执行的合同是棘手的。智能体需要在初始阶段被迫于他人签订合同，才能使得学习成功</p></li><li><p>合同</p><p>强制智能体遵循合同报价的trembling hand策略。每一个时间步长中，合同机制会确定是否有两个智能体没有参与合同，该机制在两者中随机选择一个合同，并对每个智能体的合同的logits应用掩膜（mask）。该掩膜强制每个智能体选择给定最小概率P<sub>C</sub>的合同。</p></li><li><p>图9：</p><blockquote><p>实验环境</p><p>神经网络与图7实验中神经网络完全一致，惩罚机制中选择$$b=6,$$rc=-1,P<sub>C</sub>=0.5</p></blockquote><p>所有的智能体都是合同增强的，且在学习中都有trembling Hand策略。</p><p>最初智能体学会丢弃，并签署相关丢弃行为的合同。而经过一段时间，智能体发现签订赠予合同的优势，开始相互竞争以实现实现双人联盟获得更大奖励；且未向前面绑定合同时那样学习赠予那么多东西，这是因为合同不总是完全遵守。</p><p>A图（奖励）：开始大家都学会丢弃，而后学会结盟</p><p>B图（丢弃）：大家从所有代理丢弃的情况下，逐渐学会赠予</p><p>C图（赠予）:   NG-NG代表相互非赠予合同；G-G代表相互赠予合同</p><p>D图：签订合同数量与所得筹码数呈正相关</p></li></ul><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211125_9.png" alt="9" style="zoom:67%;" /><p>结论：最初智能体学会丢弃，并签署相关丢弃行为的合同。而经过一段时间，智能体发现签订赠予合同的优势，开始相互竞争以实现实现双人联盟获得更大奖励；且未向前面绑定合同时那样学习赠予那么多东西，这是因为合同不总是完全遵守。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><strong>三项贡献</strong></p><ul><li>通过引入联盟困境的概念正式化多玩家零和博弈中的一个挑战。证明该问题普遍性存在，且基于梯度学习无法解决该问题</li><li>提出一种能够使MARL智能体组建动态团队的方法：通过使用绑定合同渠道增强智能体，使其学会使用合同作为信任潜在联盟伙伴的机制</li><li>将合同机制推广至具有约束力情况之外，智能体学会签署惩罚-强制执行的临时扩展合同</li></ul><p><strong>未来工作</strong></p><p>1）考虑在具有更大状态空间环境中的合同，处理连续联盟困境：我们可以合并一个中央智能体，如果他们希望加入联盟，他们可以推迟行动。其次，根据环境状态的抽象订立契约，而不是关于原子动作。</p><p>2）扩大合同在双边情况外的规模</p><p><strong>前景</strong></p><p>零和多人游戏引入动态团队形成和分裂问题，在多智能体方面有三条研究线：</p><ol><li>新团队的内部协调问题</li><li>团队形成过程中的社会困境问题</li><li>团队加入或离开的相关策略</li></ol><h1 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h1><ul><li><p><strong>零和游戏（Zero-sum games）</strong></p><blockquote><p>原理：两人对弈，总会有一个赢，一个输，如果我们把获胜计算为得1分，而输棋为-1分。则若A获胜次数为N，B的失败次数必然也为N。若A失败的次数为M，则B获胜的次数必然为M。这样，A的总分为（N-M），B的总分为（M-N），显然（N-M）+（M-N）=0，这就是零和游戏的数学表达式。</p><p>参考博客：<a href="https://www.jianshu.com/p/d5c078ba5b3f">什么是零和游戏 - 简书 (jianshu.com)</a></p></blockquote></li><li><p><strong>纳什均衡（ Nash equilibrium）</strong></p><p>每个玩家选择一个策略，当一个玩家不改变策略时，没有玩家能从改变策略中获益。</p></li><li><p><strong>对称零和矩阵博弈</strong>（symmetric zero-sum matrix games）</p><p>Q：在网络上搜集到的知识表明，矩阵博弈是非零和博弈</p></li><li><p><strong>极小极大定理</strong></p><p>简易理解：<a href="https://www.jianshu.com/p/7d7a2217c9a8">极简博弈论之一：极小极大与纳什均衡 - 简书 (jianshu.com)</a></p><p>（即，在外界条件取极小的情况下，取自身的极大值，实现自身利益最大化）</p></li><li><p><strong>多智能体强化学习</strong></p><blockquote><p>参考资料：</p><p><a href="https://blog.csdn.net/keypig_zz/article/details/81047623">(8条消息) 强化学习综述_评论很走心的博客-CSDN博客_强化学习综述</a></p><p><a href="https://blog.csdn.net/c9Yv2cf9I06K2A9E/article/details/104889969?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2.no_search_link">(8条消息) 多智能体强化学习（MARL）近年研究概览_Paper weekly-CSDN博客</a></p><p><a href="https://blog.csdn.net/keypig_zz/article/details/92816033">(8条消息) 多智能体强化学习综述-Lucian Busoniu_评论很走心的博客-CSDN博客_多智能体强化学习</a></p></blockquote><ul><li><p><strong>强化学习</strong>：智能体通过与动态的环境进行“尝试-错误”式的交互而学习自己应该具有什么样的行为的问题</p><ul><li><p>解决强化学习的两种策略</p><p>1）搜索行为空间来找到在环境中表现最好的行为序列</p><p>2）使用统计学和动态规划的方法建立不同环境状态下采取不同动作的效用</p></li></ul><p>强化学习模型中，智能体的任务就是找到一个策略π，将状态映射为动作（输入状态，输出动作的这样一种函数），并且最大化长期的奖励回报。</p></li></ul></li><li><p>A2C算法</p><blockquote><p>参考资料：</p><p><a href="https://www.jianshu.com/p/428b640046aa">强化学习AC、A2C、A3C算法原理与实现！ - 简书 (jianshu.com)</a></p><p><a href="https://blog.csdn.net/u013298300/article/details/100060817">(8条消息) 策略梯度与A2C算法_李兰溪的专栏-CSDN博客_a2c</a></p></blockquote></li><li><p>softmax选择策略</p></li><li><p>序贯决策博弈</p><p>参与人的决策有先有后，后决策的参与人知道 先决策的参与人已经做出的决策，这种决策有先有后的博弈，称为<em>序贯决策博弈</em></p></li><li><p>mask for the logits</p><p>向量的掩膜（mask），通俗理解：图片中有一个圆形物体，你从一张纸上剪掉一个和该物体一模一样大小的圆，把这张纸蒙在图片上，这时候你只能看见这个圆形物体，这张纸就是mask了</p></li><li><p>独热编码表示</p><blockquote><p>使用独热编码（One-Hot Encoding），将离散特征的取值扩展到了欧式空间，离散特征的某个取值就对应欧式空间的某个点。将离散型特征使用独热编码（One-Hot Encoding），会让特征之间的距离计算更加合理。<br>参考：<a href="https://www.jianshu.com/p/42e93acacc52">https://www.jianshu.com/p/42e93acacc52</a></p></blockquote></li><li><p>MLP(Muti-Layer Perception)</p><p>多层感知器。最经典MLP包括三层：输入层、隐藏层、输出层，MLP神经网络不同层之间是全连接的</p></li><li><p>LSTM(Long Short Term Mermory network)</p><p>一种特殊的递归神经网络，可具备记忆性，特点在于可以很好解决长时依赖问题。</p></li><li><p>RMSProp：一种深度学习领域的优化算法</p><p>RMSProp 算法旨在抑制梯度的锯齿下降，但与动量相比，RMSProp 不需要手动配置学习率超参数，由算法自动完成。 更重要的是，RMSProp 可以为每个参数选择不同的学习率。</p></li><li><p>head：获取网络输出，利用提取特征做出预测</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MARL </tag>
            
            <tag> 协商策略 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于最小化内容重组并容忍不完美的工作负载预测的云视频点播服务</title>
      <link href="/2021/11/20/%E7%AC%94%E8%AE%B0-%E3%80%8AMinimizing-Content-Reorganization-and-Tolerating-Imperfect-Workload-Prediction-for-Cloud-Based-Video-on-Demand-Services%E3%80%8B/"/>
      <url>/2021/11/20/%E7%AC%94%E8%AE%B0-%E3%80%8AMinimizing-Content-Reorganization-and-Tolerating-Imperfect-Workload-Prediction-for-Cloud-Based-Video-on-Demand-Services%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>基于MW算法增加一组信道作为吸收器，以消耗未使用的带宽，从而使实例重组最小化、增强工作负载预测的安全边界。基于该思想设计相应算法。</p><span id="more"></span><ul><li>2021-11-16 初步阅读论文</li><li>2021-11-17 完成1、2、3节初步阅读，在基于云的Vod系统设计部分提出疑问</li><li>2021-11-18 完成第4、5节初步阅读</li><li>2021-11-20完成文档初步整理，发布初步文档，但算法、具体效果及后期扩展部分还有待进一步完善阅读，赶在ddl前的无奈~</li></ul><h1 id="文献信息概述"><a href="#文献信息概述" class="headerlink" title="文献信息概述"></a>文献信息概述</h1><h2 id="title"><a href="#title" class="headerlink" title="title"></a>title</h2><p>笔记|《Minimizing Content Reorganization and Tolerating Imperfect Workload Prediction for Cloud-Based Video-on-Demand Services》</p><h2 id="KeyWords"><a href="#KeyWords" class="headerlink" title="KeyWords"></a>KeyWords</h2><p>动态服务器配置、视频点播、云计算</p><h2 id="Abstract-amp-Introduction"><a href="#Abstract-amp-Introduction" class="headerlink" title="Abstract &amp; Introduction"></a>Abstract &amp; Introduction</h2><p>为降低Vod服务中的成本，该文献中提出基于现交现付模式的云平台虚拟系统以实现<strong>内容重组的最小化</strong>和<strong>不完善工作负载预测的可容忍性</strong>。</p><h2 id="研究方法"><a href="#研究方法" class="headerlink" title="研究方法"></a>研究方法</h2><p>思想：基于MW算法增加一组信道作为吸收器，以消耗未使用的带宽，从而使实例重组最小化、增强工作负载预测的安全边界。基于该思想设计相应算法。</p><h2 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h2><ul><li><p>第一个从最小化内容重组和容纳不完善工作负载预测的角度提出解决方案；</p></li><li><p>当达到相同水平服务器租赁成本时：</p><p>1）内容重组被最小化</p><p>2）服务器配置的安全边际降低以进一步降低成本</p><p>3）在单位时间内具有高质量配置</p></li></ul><h1 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>自主管理的内容基础设施更可取， eg:URL链接重定向</p><p>基于现收现付的云平台构建专有虚拟基础设施</p><p>最小服务化成本（支付给云服务商的资源成本）：降低成本方法——动态服务器配置或DSP</p><p>论文脉络梳理：</p><p>主要可以分为两块：（环境）虚拟系统设计（2），内容重组、满足工作负载预测的方法（3、4、5、6）</p><h2 id="基于云的Vod系统设计"><a href="#基于云的Vod系统设计" class="headerlink" title="基于云的Vod系统设计"></a>基于云的Vod系统设计</h2><p><strong>服务器配置方式选择</strong></p><p>流媒体请求服务主要受到磁盘存储、网络带宽的限制。磁盘存储与内容存储相关；网络带宽与存储内容分配请求相关。故该文献CDN服务器选择“邀请做客”的方式，采用实例存储（服务器将内容预加载到其本地实例存储中，并在请求出现时从实例存储中获取内容），关注于Instance Placement Controller。将动态服务器的配置问题抽象为二维装箱问题处理。</p><p>Q：该方式中涉及到服务器容量有限、持久性差的缺陷如何修正？</p><p><strong>动态服务器配置问题抽象化</strong></p><p>将动态服务器的配置问题抽象为二维装箱问题处理。每个服务器都是一个具有二维的箱；每个内容都是一个具有二维的项目；目标是用最少的箱子数量打包所有的项目。</p><ul><li><p>图一 基于云的Vod系统工作图</p><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211121_1.png" alt="20211121_1"></p><p>在非峰值时期，由于工作量的减少，通过动态服务器的配置可以使服务器的成本最小化</p><p><strong>关注点</strong></p><p>该文献主要关注实例放置控制器的使用对服务器成本的显著影响</p></li></ul><h2 id="思想介绍"><a href="#思想介绍" class="headerlink" title="思想介绍"></a>思想介绍</h2><p>moving window（MV）在动态服务器配置时将其转化为CCBP问题，却未考虑实例存储重组带来的影响，同时在工作负载预测不完善条件下是次优解决方法。</p><ul><li>思路：添加空余信道作为工作负载吸收器</li></ul><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211121_2.png" alt="20211121_2" style="zoom:60%;" /><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211121_3.png" alt="20211121_3" style="zoom:50%;" /></p><p>通过添加一个信道可以明显看出，阶段变化后，在同样释放服务器C的情况下，实例重组的现象明显得到缓解</p><h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><ul><li><p>分组通道算法</p><p>在任何给定时间段内，确保每组的所有剩余容量被吸收</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211121_4.png" alt="20211121_4"></p><ul><li>周期调度算法</li></ul><p><img src="https://cdn.jsdelivr.net/gh/HSmiling/Images/20211121_5.png" alt="20211121_5"></p><h1 id="知识补充"><a href="#知识补充" class="headerlink" title="知识补充"></a>知识补充</h1><ul><li><p>CDNS(content distribution networks)内容分发网络</p><blockquote><p>基本原理是在现有Internet中新增一层网络架构，将网站的内容发布到最接近用户的网络”边缘”，使用户可以就近取得所需的内容，解决Internet网络拥塞状况，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，解决用户访问网站的响应速度慢的根本原因。</p><p>参考博客：<a href="https://blog.csdn.net/charlene0824/article/details/52127824">(5条消息) CDN（内容分发网络）技术概述_charlene0824的博客-CSDN博客_内容分发网络</a></p></blockquote><ul><li><p>要件</p><p>分布式存储、负载均衡、网络请求的重定向、内容管理</p><p>注：内容管理和全局网络流量管理是核心</p></li><li><p>CDN节点组成部分：负载均衡设备、高速缓存服务器</p></li><li><p>CDN两种服务器安置原则</p><ul><li><p>深入</p><p>由Akamai首创，通过在遍及全球的接入ISP中部署服务器集群来深入到ISP的接入网中，是一种高度分布式设计，维护和管理集群困难；靠近端用户，通过减少端用户和CDN集群之间链路和路由器的数量，从而改善用户感受的时延和吞吐量；</p></li><li><p>邀请做客</p><p>由Limelight和其它CDN公司采用，通过在少量关键位置建造大集群来邀请ISP做客；不是将集群放在接入ISP中，这些CDN通常将它们的集群放置在因特网交换点（IXP）；</p><p>（本文关注于服务器与用户之间的吞吐量，故选择“邀请做客”的方式）</p></li></ul></li></ul></li><li><p>视频点播服务（Video-on-demand）</p><p>eg：典型在线Vod服务提供商：youku、netFlix</p></li><li><p>pay-as-you-go cloud</p><p>现收现付（PAYG）是一种公用计算计费方法，在云计算中面向组织和最终用户实施</p><blockquote><p>PAYG 允许用户扩展，定制和配置计算资源，包括软件，存储和开发平台。资源费用基于已使用的服务，而不是整个基础架构。</p><p>公共云资源以不同方式处理和应用 PAYG 模型。例如，供应专用云服务器的用户通常根据服务器功率和使用情况以及经常性地计费。软件即服务（SaaS）的工作方式类似，用户租用软件和自定义功能。存储即服务（SaaS）计费经常轮换，因为存储需求的增加通常会逐渐增加定价。</p><p>现收现付制亦称“收付实现制”。是以货币实际收付的时间作为核算的标准，来确定本期收入和支出的一种会计核算方法。按照这种标准，任何收益，在未实际收到货币资金之前，不认为是收益;任何费用，在未实际付出货币资金之前，也不算是费用。即凡在本期实际收到款项的收益和付出款项的费用，不论其是否应属于本期，均作为本期收益和费用处理，凡在本期没有实际收到款项，即使有些收益和费用已经发生，也不作为本期的收益和费用处理。</p><p>选自：<a href="https://www.leixue.com/ask/pay-as-you-go">现收现付是什么 - 泪雪网 (leixue.com)</a></p></blockquote></li><li><p>EBS</p><p>参考文档：<a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/AmazonEBS.html">Amazon Elastic Block Store (Amazon EBS) - Amazon Elastic Compute Cloud</a></p></li><li><p>装箱问题（packing problem）</p><blockquote><p>经典的装箱问题：要求把一定数量的物品放入容量相同的一些箱子中,使得每个箱子中的物品大小之和不超过箱子容量并使所用的箱子数目最少。</p><p>二维装箱问题（two-dimensional bin packing problem）：考虑两个因素——给定一张矩形的纸（布料、皮革），要求从这张纸上剪出给定的大小不一的形状，求一种剪法使得剪出的废料的面积总和最小。</p></blockquote><p>在该文献中将动态服务器配置转换为二维装箱问题，每个服务器都是一个具有二维的箱；每个内容都是一个具有二维的项目；目标是用最少的箱子数量打包所有的项目。（two-dimensional bin packing problem）</p><ul><li><p>CCBP(the class constrained bin packing problem)</p><p>有M个不同类的单位大小的项目，需要打包道N个背包中，目的是找到以恶使N 最小化的配置方案，使NP-Hard问题</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> 动态服务器配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA00随记</title>
      <link href="/2021/11/13/PA00/"/>
      <url>/2021/11/13/PA00/</url>
      
        <content type="html"><![CDATA[<p>PA00主要是针对总体实验的了解和linux的基本使用</p><span id="more"></span><h1 id="在Linux系统中编写c程序"><a href="#在Linux系统中编写c程序" class="headerlink" title="在Linux系统中编写c程序"></a>在Linux系统中编写c程序</h1><p>先建立相关文件，并输入c程序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi test.c</span><br></pre></td></tr></table></figure><p>程序内容如下：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world! hsmiling\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存后，在命令行中对程序进行编译，最终生成程序test。指令如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gcc test.c -o test</span><br></pre></td></tr></table></figure><p>在命令行执行./test，运行程序</p><ul><li><p>扩展</p><p>编译过程实际上分为四个阶段：</p><blockquote><p>预处理   编译   汇编   连接</p></blockquote><p>详细解答可参考：<a href="https://www.cnblogs.com/lvchunhao/p/3854718.html">https://www.cnblogs.com/lvchunhao/p/3854718.html</a></p></li></ul><h1 id="什么是makefile"><a href="#什么是makefile" class="headerlink" title="什么是makefile"></a>什么是makefile</h1><p>参考博客链接：</p><p><a href="https://blog.csdn.net/weixin_44160754/article/details/109731335?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.no_search_link&amp;spm=1001.2101.3001.4242.2">https://blog.csdn.net/weixin_44160754/article/details/109731335?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.no_search_link&amp;spm=1001.2101.3001.4242.2</a></p><p><a href="https://blog.csdn.net/qq_42111463/article/details/88380812">https://blog.csdn.net/qq_42111463/article/details/88380812</a></p><p>makefile的一般格式为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">target: dependency1 dependency2</span><br><span class="line">action1</span><br><span class="line">action2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>根据上述简单的helloworld操作，则在该目录下新建makefile文件，并加入：</p><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">test:</span></span><br><span class="line">gcc -o test test.c</span><br></pre></td></tr></table></figure><p>保存后在命令行输入make指令，再输入./test即可成功编译</p><h1 id="Tumx分屏常用指令"><a href="#Tumx分屏常用指令" class="headerlink" title="Tumx分屏常用指令"></a>Tumx分屏常用指令</h1><p>终端输入tmux进行界面：</p><blockquote><p>上下分屏：ctrl + b  再按 “</p><p>左右分屏：ctrl + b  再按 %</p><p>切换屏幕：ctrl + b  再按o</p><p>关闭一个终端：ctrl + b  再按x</p><p>上下分屏与左右分屏切换： ctrl + b  再按空格键</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA实验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>win10+Debian11双系统的配置小记</title>
      <link href="/2021/11/11/Win10+Debian11%E5%8F%8C%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/11/11/Win10+Debian11%E5%8F%8C%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>记录第一次搭建双系统的过程</p><span id="more"></span><h2 id="01-前期准备"><a href="#01-前期准备" class="headerlink" title="01 前期准备"></a>01 前期准备</h2><p>注：在准备安装双系统前，一定要做好备份工作</p><p>该配置需要的环境如下：</p><ul><li>一个大于等于8G的USB或DVD，作为系统的安装盘</li><li>需要配置双系统的电脑、一台可联网的设备（用于在安装过程中查漏补缺）</li><li>良好且稳定的网络环境</li></ul><h3 id="步骤一：镜像准备与下载"><a href="#步骤一：镜像准备与下载" class="headerlink" title="步骤一：镜像准备与下载"></a>步骤一：镜像准备与下载</h3><p>没有有线网络的情况下，推荐下载完整安装镜像，大小是3-4G，否则可能存在很多软件缺失，后期在安装过程中比较麻烦，在这里我选择官方镜像下载：</p><blockquote><p><a href="https://cdimage.debian.org/debian-cd/current/amd64/iso-dvd/debian-11.1.0-amd64-DVD-1.iso">debian-11.1.0-amd64-DVD-1.iso</a></p></blockquote><p><strong>特别注意</strong>：在官网上下载的完整版镜像，缺少iwlwifi相关驱动，若直接使用在安装过程中会提示驱动缺失，且在安装后可能会导致网络配置有问题，故我们需要再下载补充的驱动：</p><blockquote><p><a href="https://packages.debian.org/sid/all/firmware-iwlwifi/download">Debian – 软件包下载地址选择 – firmware-iwlwifi_20210818-1_all.deb</a></p></blockquote><h3 id="步骤二：创建空余分区"><a href="#步骤二：创建空余分区" class="headerlink" title="步骤二：创建空余分区"></a>步骤二：创建空余分区</h3><p>需要在硬盘上创建用于安装Debian系统的空余分区，运用磁盘管理器即可，我在这新分配了60G.</p><p>创建空余分区详见步骤1：<a href="https://zhuanlan.zhihu.com/p/91194918">如何拥有一个 Windows 10 和 Debian 10 的双系统 - 知乎 (zhihu.com)</a></p><h3 id="步骤三：创建U盘启动盘"><a href="#步骤三：创建U盘启动盘" class="headerlink" title="步骤三：创建U盘启动盘"></a>步骤三：创建U盘启动盘</h3><p>在这里我使用Rufus创建USB启动盘，先下载可引导USB闪存盘的工具rufus：</p><blockquote><p><a href="http://rufus.ie/zh/">Rufus - 轻松创建USB启动盘</a></p></blockquote><p>将U盘插在电脑上，打开rufus软件，引导类型选择已下载的镜像文件，分区类型选择GPT，目标系统类型选择UEFI，进行创建</p><p><strong>iwlwifi驱动的插入</strong></p><p>将上一步下载好的iwlwifi固件复制黏贴到U盘的fireware文件中</p><h2 id="02-安装过程"><a href="#02-安装过程" class="headerlink" title="02 安装过程"></a>02 安装过程</h2><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>注：该过程中USB需一直维持插入电脑中，直至系统安装完毕</p><ol><li><p>重新启动，在欢迎界面时进入BIOS界面更改引导顺序（thinkpad中是按F12键），选择U盘启动</p></li><li><p>进入图形化安装界面，该部分详细操作参考：</p><blockquote><p><a href="https://blog.csdn.net/weixin_51216104/article/details/120272993?ops_request_misc=%7B%22request_id%22:%22163549009816780261963151%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=163549009816780261963151&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-120272993.pc_search_result_hbase_insert&utm_term=debian11%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B&spm=1018.2226.3001.4187">(1条消息) Win10系统下安装Debian11教程_@小宋同学的博客-CSDN博客</a></p></blockquote><p>在安装过程中，我选择安装的是英文环境，由于是新手，硬盘分区直接选的是默认模式。</p><p>注意：安装过程中需要联网，有条件的可以事先准备好网线。没有有线网的情况下，我直接连了自己的热点，但真正用到的流量不多</p></li><li><p>成功进入到页面中</p></li></ol><h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p><strong>问题：网络配置错误，缺少iwlwifi网卡驱动相关固件</strong></p><blockquote><p>两种解决方案：</p><p>一种是我前文提到事先在镜像中添加；</p><p>一种是跳过该步骤在安装结束后再安装驱动。</p></blockquote><p>建议使用第一种方案，因为在安装后可能存在联网问题，没有另一台联网主机的帮助可能解决问题较为艰难</p><h2 id="03-Debian的日常配置"><a href="#03-Debian的日常配置" class="headerlink" title="03 Debian的日常配置"></a>03 Debian的日常配置</h2><h3 id="sudo权限配置"><a href="#sudo权限配置" class="headerlink" title="sudo权限配置"></a>sudo权限配置</h3><ul><li><p>问题</p><p>用户使用sudo命令时报错：</p><blockquote><p>xxx is not in the sudoers file，This incident will be reported.（其中xxx是用户名）</p></blockquote><p>这是由于Debian初始情况下为将用户加入到sudo配置文件中</p></li><li><p>解决方法</p><p>运行终端，键入：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#切换至root用户权限</span></span><br><span class="line">su root</span><br><span class="line"><span class="comment">#切换到根目录下</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="comment">#添加文件写权限</span></span><br><span class="line">chmod u+w ../etc/sudoers</span><br><span class="line"><span class="comment">#编辑文件</span></span><br><span class="line">vi /etc/sudoers</span><br></pre></td></tr></table></figure><p>进入文件中，找到”root ALL=(ALL:ALL) ALL”这一行，在下一行添加：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxx ALL=(ALL:ALL) ALL <span class="comment">#xxx为用户名</span></span><br></pre></td></tr></table></figure><p>保存文件后退出，撤销文件的写权限：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod u-w ../etc/sudoers</span><br></pre></td></tr></table></figure></li></ul><h3 id="替换源的配置"><a href="#替换源的配置" class="headerlink" title="替换源的配置"></a>替换源的配置</h3><p>Debian默认的官方源下载速度较慢，由于后续的软件安装时需使用到网络安装，故安装时更换为TUNA的软件源镜像。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开配置文件</span></span><br><span class="line">vi /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>将源码镜像注销，将下述文本添加至配置文件中：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye main contrib non-free</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-updates main contrib non-free</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian/ bullseye-backports main contrib non-free</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/debian-security bullseye-security main contrib non-free</span></span><br></pre></td></tr></table></figure><p>在终端上进行apt的更新，键入如下指令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><p>参考<a href="https://zhuanlan.zhihu.com/p/402267392">Debian 11 “bullseye” 配置指南 - 知乎 (zhihu.com)</a>中更换国内镜像部分</p><h3 id="中文输入配置（英文环境下）"><a href="#中文输入配置（英文环境下）" class="headerlink" title="中文输入配置（英文环境下）"></a>中文输入配置（英文环境下）</h3><p>虽然安装的是英文环境，但是中文的输入法还是不能割舍的，但是输入法的安装过程博客中众说纷纭。我选择安装fcitx，推荐下面这篇基于英文环境安装的博客，亲测有效：</p><blockquote><p><a href="https://blog.csdn.net/u010571102/article/details/103434791?ops_request_misc=&request_id=&biz_id=102&utm_term=debian11%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E9%85%8D%E7%BD%AE%EF%BC%88%E8%8B%B1%E6%96%87%E7%8E%AF%E5%A2%83%E4%B8%8B%EF%BC%89&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-4-103434791.pc_search_result_hbase_insert&spm=1018.2226.3001.4187">(1条消息) Debian10(英文环境)安装中文输入法fcitx_summer的博客-CSDN博客_debian fcitx</a></p></blockquote><p><strong>注意：</strong></p><p>英文环境的小伙伴在安装前切记要在locales中安装一下中文的环境，不然后续过程可能无法实现输入法的转换</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA实验 </tag>
            
            <tag> 环境搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客初识</title>
      <link href="/2021/11/10/Hexo%20%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/11/10/Hexo%20%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>2021-11-10开通了属于HSmiling的博客，该博客主要记录学习过程中的笔记及一些生活上的感受，期待能长久的更新下去。<br>那就先立个flag，一周至少一篇吧~<br>——HSmiling 写于2021.11.11</p><span id="more"></span><h2 id="Hexo常见指令"><a href="#Hexo常见指令" class="headerlink" title="Hexo常见指令"></a>Hexo常见指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span> <span class="comment">#新建文章 </span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment">#新建页面 </span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录 </span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server） </span></span><br><span class="line">hexo deploy <span class="comment">#部署到GitHub </span></span><br><span class="line">hexo <span class="built_in">help</span>  <span class="comment">#查看帮助 </span></span><br><span class="line">hexo version  <span class="comment">#查看Hexo的版本</span></span><br></pre></td></tr></table></figure><p>缩写：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure><p>组合命令：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 指令 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
